# Data Management in SAS

```{r mind map,echo = F,message = FALSE, error = FALSE, warning = FALSE}
library('mindr')
### text -> widget
### input <- c("# Chapter 1", "## Section 1.1", "### Section 1.1.1", "## Section 1.2", "# Chapter 2")
### mm(from = input, type = "text", root = "mindr")
filename <- rstudioapi::getSourceEditorContext()$path
widget <- mm(from = filename, type = "file", root = "")
widget
```



## Input data into SAS

### Native datasets input

```
libname libref "dir_location";
data ds;
  set libref.sasfilename; /* Note: no file extension */
  ...
run;

data ds;
set "dir_location\sasfilename.sas7bdat"; 
     /* Windows only */
set "dir_location/sasfilename.sas7bdat";
     /* works on all OS including Windows */
run;
```

### Reading free formatted data instream

```
DATA data1;
 INPUT make $ model $ mpg weight price;
CARDS;
AMC Concord 22 2930 4099
AMC Pacer   17 3350 4749
AMC Spirit  22 2640 3799
Buick Century 20 3250 4816
Buick Electra 15 4080 7827
;
RUN; 
```

### Reading fixed formatted data instream

It need to provide the beginning and ending column numbers for each variable.
 
```
DATA data2;
  INPUT make $ 1-5 model $ 6-12 mpg 13-14 weight 15-18 price 19-22;
CARDS;
AMC  Concord2229304099
AMC  Pacer  1733504749
AMC  Spirit 2226403799
BuickCentury2032504816
BuickElectra1540807827
;
RUN;
```

### INFILE: Reading fixed formatted data from an external file

```
The data3.dat file:

AMC  Concord2229304099
AMC  Pacer  1733504749
AMC  Spirit 2226403799
BuickCentury2032504816
BuickElectra1540807827 

DATA cars3;
  INFILE "~/path/data3.dat";
  INPUT make $ 1-5 model $ 6-12 mpg 13-14 weight 15-18 price 19-22;
RUN;

*** with special (comma) delimited
*** tab delimited: DELIMITER='09'x;
*** comma delimited: delimiter=',';

AMC,Concord,22,2930,4099
AMC,Pacer,17,3350,4749
AMC,Spirit,22,2640,3799
Buick,Century,20,3250,4816
Buick,Electra,15,4080,7827 

DATA cars5;
  INFILE "~/path/data3.dat"  delimiter=',';
  INPUT make $ model $ mpg weight price;
RUN;
```

### Write the SAS File

```
libname diss 'c:dissertation';
 
data diss.salary;
  input sal1996-sal2000 ;
  cards;
10000 10500 11000 12000 12700
14000 16500 18000 22000 29000
;
run;

data 'c:dissertationsalarylong';
  input Salary1996-Salary2000 ;
cards;
10000 10500 11000 12000 12700
14000 16500 18000 22000 29000
;
run;
```


### Import csv data

```
PROC IMPORT  datafile="Z:\path\data4.csv"
        out=outname
        dbms=csv
		replace;
		delimiter=";";
        getnames=yes;
		Guessingrows=MAX;
RUN;
```

### %Import

Import all SAS datasets available in a specific folder

| Macro Variables | Description                                                                                                            |
|-----------------|------------------------------------------------------------------------------------------------------------------------|
| folder_path     | File path with the data that are to be imported;                                                                       |
| delete_all      | If delete_all is unequal 1 then all datasets in the work-library are deleted, else if it is 1 no datasets are deleted; |
| fname&i         | Macro variable that contains the dataset name                                                                          |
| total           | Number of all datasets within a folder                                                                                 |


```
%macro Import (folder_path, delete_all);
	*** delete all datasets if delete_all is 1;
	%if &delete_all ne 1 %then %do;
		proc datasets library=work kill nolist; run; quit;
		dm log 'clear';
	%end;

	libname IMPORT "&folder_path";

	*** definition of folder with the datasets;
	proc sql;
		create table m_dataset_list as select distinct memname from dictionary.tables
		where libname="IMPORT" and memtype="DATA";
	quit;

	*** declare macro variables containing the name of a dataset in the specified folder and their overall number; 
	data m_dataset_list;
		set m_dataset_list end=last;
		retain i 0;
		i=i+1;
		call symput('fname'||trim(left(put(i,8.))),scan(trim(memname),1,'.'));
		if last then call symput('total',trim(left(put(i,8.))));
	run;


	*** import by means of the macro variables defined above ; 
	libname libdata "&folder_path";
	libname library (libdata); 	
	%do i=1 %to &total;
		data work.&&fname&i; set libdata.&&fname&i; 
		run;
	%end;
%mend Import;

%Import (folder_path=Z:\...\,
		 delete_all=);
```

### URL

```
filename urlhandle url 'http://www.math.smith.edu/sas/testdata';
filename urlhandle url 'http://www.math.smith.edu/sas/testdata' 
         user='your_username' pass='your_password';
proc import datafile=urlhandle out=ds dbms=dlm;
run;

```

### Infile Read multiple raw data files

```
* data step to read in data;
data mydata;
  length inname $ 100;
  input inname $;

  infile dummy filevar=inname end=EOF;
  do until (EOF);

    * PUT YOUR INPUT STATEMENT HERE TO READ IN YOUR DATA;
    input year 1-4 name $ 6-28 party $ 30-34 born 35-38 died 40-43
          age 45-46 stborn $ 48-49 stelec $ 51-52 religion $ 54-65
          elecvote 67-69 popvote 71-78;

    * DO ANY PROCESSING OF THE DATA HERE (E.G. COMPUTING NEW VARIABLES);
    output;
  end;
cards;
c:winners1.txt
c:winners2.txt
run;
```

### Generate automatic file name

If you create multiple data sets in SAS, you may want to name them in an automated way. How to create a file name based on date and time. Such a file naming process will 1) prevent you from providing the same file name to two different data sets, and 2) allow you to see when the file was first created.

```
data tsave;
  do i = 1 to 10;
    do time = 1 to 5;
	   y = rannor(1232+i + time);
       output;
  	end;
  end;
run;

data _null_;
  cdate =  "&SYSDATE9";
  ctime = "&SYSTIME";
  time_string = cdate||"_"||translate(ctime, "_", ":");
  call symput('mytime', time_string);
run;

data "c:tempnewdata_&mytime";
  set tsave;
run;
```




## Format the variables

### Proc format 

```
proc format;
    value eye_CAT    1 = "OD"
	                   2 = "OS";
	  value AR_CAT     1 = "^{unicode 2264} 3° absolute rotation"
	                   2 = "^{unicode 2264} 5° absolute rotation"
									   3 = "^{unicode 2264} 7° absolute rotation"
								     4 = "^{unicode 2264} 10° absolute rotation"
								     5 = "^{unicode 2264} 20° absolute rotation"
								     6 = "^{unicode 2264} 30° absolute rotation";
run;
```

### Copy and combine SAS format libraries

```
libname first "etempdata1";
libname second "etempdata2";

proc catalog cat=first.FORMATS;
  copy out=second.FORMATS;
run;
```

### Build a format from a dataset

```
Outcode  Outname
  101      Aberdeen
  102      Altrincham
  103      Ashford
  104      Barnsley
  105      Basildon
  106      Basingstoke
  107      BathFirst 
  
data work.outfmt(keep=start label fmtname);  
  set work.outlets(rename=(outcode=start outname=label));  
  fmtname='outfmt';
run;
proc format library=work cntlin=work.outfmt;
run;
```

### Output format as datasets

```
proc format library=work cntlout=format_dataset;
run;
```
,0

### Delete the format

```
proc catalog catalog=work.formats;
	delete eye_CAT.format Visit_CAT.format;
run;
```

### 'CAT' connect string variables

```
data test;
   infile cards missover;
   length first last $20;
   input first $ last $  ;
datalines;
jone smith
john wayne
bill 
phil hodge
;
run;
data test2;
  set test;
  name = catx(", ", of last first );
  name1 = cat(of last first);
  name2 = cats(of last first); /*leading and trailing blanks*/
  name3 = catt(of last first); /*trailing blanks*/
run;
proc print data = test2;
run;

##############################################################################
   Obs    first    last     name                    name1              name2        name3

    1     jone     smith    smith, jone    smith               jone    smithjone    smithjone
    2     john     wayne    wayne, john    wayne               john    waynejohn    waynejohn
    3     bill              bill                               bill    bill         bill
    4     phil     hodge    hodge, phil    hodge               phil    hodgephil    hodgephil
```

```
 Submit this file to define the %CLASSIFY macro.  You may then 
 invoke the macro to process the output data set from LOGISTIC or 
 PROBIT.  The EXAMPLE section below shows how to invoke the macro.

 The following parameters are required when using the macro:

 data=        Name of LOGISTIC or PROBIT OUT= data set.  If not 
              specified, the last data set created is used.
 response=    Name of response variable used in LOGISTIC or PROBIT.
 p=           Name of PREDICT= variable in OUT= data set.

 The following parameters are optional:

 threshld=0   Minimum predicted probability which must be attained
              for an observation to be classified into a response
              level.  The specified value must be between 0 and 1.
 predname=_predlvl
              Names the variable in the OUT= data set containing the
              predicted response level.  Do not use the same name as
              given in the P= parameter.  If not specified, the
              variable is named _PREDLVL.
 out=classout Names the output data set containing individual-level
              predicted probabilities and the predicted response
              level.  If not specified, the data set is named
              CLASSOUT.
              
              
/*
 Catenate a set of variable values, with a specified separator.

 Useful for situations were you need to combine a number of factor
 variables into a single variable, e.g., to plot means for the
 combinations of two or more factors.
 
 V9 has the function catx(sep, str1, str2, ...), that does something
 similar, and other functions, cat(str1, ...), cats(str1, ...),
 catt(str1, ...)  that don't provide an explicit separator argument.
*/
%macro cat(
	data=_last_,   /* input dataset */
	var=,          /* list of variables to be concatenated */
	catvar=,       /* output result variable */
	sep=:,         /* separator string */
	length=,       /* length of result variable */
	out=&data      /* name of output dataset */
	);

%local catstr i v;
data &out;
	set &data;
	%if %length(&length) %then %do;
		length &catvar $ &length;
		%end;
	%let catstr = trim(left(%scan(&var,1,%str( ))));
	%let i=2;
	%let v=%scan(&var, &i, %str( ));
	%do %while (%length(&v) > 0 );
		%let catstr = &catstr || "&sep" || trim(left(%scan(&var,&i,%str( ))));
		%let i = %eval(&i+1);
		%let v=%scan(&var, &i, %str( ));
		%end;
	%*put CAT: &catvar = &catstr;
	&catvar = &catstr;
	
%mend;
```


### %Combine

The COMBINE macro combines two or more variables (characters or numbers) into one variable. This is useful in situations where two or more CLASS variables are needed but some procedures or macros only handle one. It is also very convenient for plots in tabular form

| Var      |  Des.                                                                                                                                                                                                                   |
|----------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| DATA=    | The name of the input data set [Default: DATA=LAST]                                                                                                                                                                     |
| VAR=     | List of two or more variables to be combined. required                                                                                                                                                                  |
| RESULT=  | The name of the result variable. [Default: RESULT=ID]                                                                                                                                                                   |
| WHERE=   | Otional WHERE clause to subset the observations written to the OUT= data set.                                                                                                                                           |
| SEP=     | Separator character(s), inserted between adjacent values [Default: SEP=:]                                                                                                                                               |
| ABBREV=  | If specified, each character variable in VAR= is truncated to this length in RESULT. To specify different truncation lengths, use a list of numbers, whose order corresponds to the VAR= variables, e.g., ABBREV=2 2 4. |
| LENGTH=  | If specified, the RESULT= variable is truncated to this total length, regardless of the ABBREV= setting.                                                                                                                |
| USEFMT=  | If postive, numeric variables which have formats stored in the data set have their formatted values combined. [Default: USEFMT=0]                                                                                       |
| IGNMISS= | Ignore missing values?                                                                                                                                                                                                  |
| OUT=     | The name of the output data set. The default (OUT=&data) means that the input data set is replaced. [Default: OUT=&data]                                                                                                |

```
%macro combine(
	data=_last_,    /* name of input dataset                       */
	var=,           /* list of variables to be combined            */
	where=,         /* WHERE clause to subset the data             */
	result=_id_,    /* result variable                             */
	sep=:,          /* separator character                         */
	abbrev=,        /* abbreviated length of each char variable    */
	length=,        /* max total length of RESULT                  */
	usefmt=0,       /* use formats for numeric variables?          */
	ignmiss=0,      /* ignore missing values?                      */
	out=&data       /* name of output dataset                      */
	);
	
%let var=%upcase(&var);
%*let var=%vexpand(&var);       *-- Uncomment to make this work for VAR=X1-X5;

%let nv=%words(&var,root=_v_);  *-- Get number of VAR= variables, create _v_1 ... ;
%if %upcase(&data)=_LAST_ %then %let data=&syslast;
/*
%if &nv < 2 %then %do;
	data &out;
		set &data;
		%if &usefmt %then %do;
		_fmt_=vformat(&var);
		put _fmt_=;
		if vtype(&var)='N' then
			&result=left(trim(put(&var, _fmt_));
		else &result = &var;
			%end;
		%else %do;
		&result = &var;
			%end;
	run;
	%put WARNING:  Only &nv VAR= variable was specified.  &data has been copied to &out;

	%goto done;
	%end;
%*put nv=&nv;
*/

options nonotes;
proc contents data=&data  noprint 
     out=_vars_(keep=name type format length);
  run;

data _null_;
	set _vars_ end=eof;
	%do i=1 %to &nv;
		if upcase(name) = upcase("&&_v_&i") then do;
			call symput('_t_'||"&i", put(type,1.0));
			if format ^= ' ' and index(format,'.')=0 then format=trim(format)||'.';
			call symput('_f_'||"&i", format);
			* put name= format=;
			len + length+%length(&sep);
			end;
		%end;
	if eof then do;
		call symput('_len_', left(put(len, 8.0)));
		end;
run;

%if %length(&length)>0 %then %do;
	%if %verify(&length,  %str(0123456789))=0
		%then %let _len_ = &length;
	%end;

%if %length(&abbrev)>0 %then %do;
	%if %verify(&abbrev,  %str(0123456789 ))>0
		%then %do;
			%put WARNING:  Non-numeric ABBREV= &abbrev has been ignored.;
			%let abbrev=;
			%end;
	%end;

%put COMBINE: Length of &result = &_len_;
options notes;
data &out;
	set &data;
	%if %length(&where) %then %do;
		where &where;
		%end;
	length &result $&_len_;;
	&result = '';
	%let s=;
	%do i=1 %to &nv;
		
		%if &i>1 & %length(&sep)>0 %then %do;
			&result = trim(&result) || trim("&sep");
			%end;

		%if &&_t_&i = 1 %then %do;  /* numeric */
			length  _tmp_ $&_len_;;
	 		drop _tmp_ ;
			%if &ignmiss>0 %then %do;
				if not missing(&&_v_&i) then do;
			%end;
			%if &usefmt>0 and %length(&&_f_&i)>0 %then %do;
				_tmp_ = left(put(&&_v_&i, &&_f_&i));
				%end;
			%else %do;
				_tmp_ = left(put(&&_v_&i, best8.));
				%end;
			&result = trim(&result) || _tmp_;

			%if &ignmiss>0 %then %do;
				end;
				%end;
			%end;  /* numeric */
			
		%else %do;  /* character */
				%if %length(&abbrev)>0 %then %do;
				   %let ab = %scan(&abbrev,&i);
				   %if &ab= %then %let ab= %scan(&abbrev,1);
				   &result = trim(&result) || 
					   substr(&&_v_&i,1,min(&ab,length(&&_v_&i)));
				   %end;
			   %else %do;
				   &result = trim(&result) || &&_v_&i;
				   %end;
			%end;  /* character */
%next:
		%end;
run;
%done:	
%mend;

%macro words(string,root=);
%*--------------------------------------------------;
%* Return number of words in string. If root ^' ',  ;
%* then create global variables starting with root. ;
%*--------------------------------------------------;
   %local count word;
   %let count=1;
   %let word = %scan(&string,&count,%str( ));
   %do %while(&word^= );
	%*put WORDS: word=&word;
       %if &root^=  %then %do;
          %global &root&count;
          %let &root&count=&word;
       %end;
       %let count = %eval(&count+1);
       %let word = %scan(&string,&count,%str( ));
   %end;
   %eval(&count-1)
%mend words;

data design;
   do task =  'EASY', 'HARD';
      do dose = ., 0 to 2;
	     do try = "BIG","SMALL";
           output;
	     end;
     end;
  end;
run;
%combine(data=design, var=task dose try, SEP= _, out=test);
```

| bs | task | dose | try | id         |
|---:|------|-----:|-----|------------|
|  1 | EASY |    . | BIG | EASY_._BIG |
|  2 | EASY |    . | SMA | EASY_._SMA |
|  3 | EASY |    0 | BIG | EASY_0_BIG |
|  4 | EASY |    0 | SMA | EASY_0_SMA |
|  5 | EASY |    1 | BIG | EASY_1_BIG |


## Array

### Defining

`array array-name {n} <$><length> <array-elements> <(initial-value-list)>;`

$$
\begin{array}{|l|l|}
\hline \text { Component } & \text { Description } \\
\hline \text { array-name } & \text { a valid SAS name that will be used to identify the group of variables } \\
\hline \mathrm{n} & \begin{array}{l}
\text { a subscript that refers to the number of elements or variables in the array that should be enclosed in either } \\
\text { parentheses ( ), braces }\{\} \text { , or brackets [ ] }
\end{array} \\
\hline \$ & \text { a component added to the statement to specify that the elements within the array are of character type } \\
\hline \text { length } & \text { a common length of the elements in the array } \\
\hline \text { array-elements } & \text { a list of the variables to be part of the array that must be all the same type, either all numeric or all character } \\
\hline \text { initial-value-list } & \text { a list of initial values for each of the array elements } \\
\hline
\end{array}
$$

**simple examples**

* `array charsamp {5} $ 10 varc1 varc2 varc3 varc4 varc5;`
* `array numsamp (*) var1 var2 var3;`
* `array initsamp [2] $ init1 init2 (‘A’, ‘B’);`

**Using Arrays in simple iterative DO loop**

```
do i=1 to 5;
if numsamp[i] =. then numsamp[i] = 0;
end;

do i=1 to dim(numsamp);
if numsamp[i] =. then numsamp[i] = 0;
end;
```

### Format multiple variables


```
data sample_sae2;
set sample_sae1;
 array saen {*} _aesdth _aeslife _aeshosp _aesdisab _aescong _aesmie;
 array saec {*} $1 aesdth aeslife aeshosp aesdisab aescong aesmie;
 do i=1 to dim(saec);
 if saen{i} = 1 then saec{i} = 'Y';
 else if saen{i} = 0 then saec{i} = 'N';
 end;
run;
```

Custom Formats

```
proc format;
value YN
1 = 'Y'
0 = 'N';
run;

do i=1 to dim(saec);
if ~missing(saen{i}) then saec{i} = put(saen{i},yn.);
end;
```

Format the summary statistics


```
length contivar	$200.
			   n_c mean_c  std_c	min_c	q1_c	median_c	q3_c	max_c	$100.;
		contivar ="";

		array stat_num	{*} n nmiss	mean 	std 	min 	q1 		median 		q3 		max;
		array stat_char	{*} n_c nmiss_c mean_c  std_c	min_c	q1_c	median_c	q3_c	max_c;
        
        *** make sure only variable no mis, otherwise variable miss is uninitialized;
		if n ne .      then		n_c 	  =	strip(put(round(n,1.),8.));
		if nmiss ne .  then		nmiss_c	  =	strip(put(round(nmiss,1.),8.));
		if mean ne .   then		Mean_c    = strip(put(round(mean,0.001),8.3));
		if std ne .    then		Std_c  	  = strip(put(round(std,0.001),8.3));
		if min ne .    then		Min_c  	  = strip(put(round(min,0.01),8.2));
		if q1 ne .     then		Q1_c   	  = strip(put(round(q1,0.001),8.3));
		if median ne . then		Median_c  = strip(put(round(median,0.001),8.3));
		if Q3 ne .     then		Q3_c      = strip(put(round(q3,0.001),8.3));
		if Max ne .    then		Max_c     = strip(put(round(max,0.01),8.2));
		if nmiss ne .  then		nmiss_p   = divide (nmiss,_freq_);
		if nmiss ne .  then		nmiss_p_c = "^R/RTF'\ql' " ||" " || strip("(" || put(round (nmiss_p*100,0.1),5.1) || ")");

		do stat=1 to dim(stat_char);
			if 		stat_num[stat] ge  100 then stat_char[stat] = "^R/RTF'\qr' " 	  || strip(stat_char[stat]); 
			else if stat_num[stat] ge   10 then stat_char[stat] = " ^_^R/RTF'\qr' "   || strip(stat_char[stat]); 
			else if stat_num[stat] ge    0 then stat_char[stat] = " ^_^_^R/RTF'\qr' " || strip(stat_char[stat]); 
			else if stat_num[stat] le -100 then stat_char[stat] = "^R/RTF'\qr' "      || strip(stat_char[stat]);
			else if stat_num[stat] le  -10 then stat_char[stat] = "^R/RTF'\qr' "	  || strip(stat_char[stat]);
			else if stat_num[stat] ge   -1 then stat_char[stat] = "^_^R/RTF'\qr' "    || strip(stat_char[stat]);
		end;
```

### 2*2 arrays

```
data anon_D06_glossary;
	LENGTH 	Description $200.;
	*** 6 Groups (COLs), max. 4 Subgroups (ROWs);
	array grps_subgrps{5,6} (		0	1	2	3	4	5
									01	11	21	31	41	51
									.	12	22	32	.	.
									.	.	.	33	. 	.
									.	.	.	34	. 	.);
	do i = 1 to dim2(grps_subgrps);
		IF grps_subgrps[1,i] EQ &GROUP. THEN DO;
			do j = 2 to dim1(grps_subgrps);
					if grps_subgrps[j,i] ne . then do;
						Description = &label.;
						GROUP = grps_subgrps[1,i];
						SUBGROUP = grps_subgrps[j,i];
						output;
					end;
			end;
		END;
	end;
	drop grps_subgrps: i j;
	set anon_D06_fmt (in = a);
run; 
```

### Dynamic Element List using Macro Variables

```
proc sql noprint;
select distinct NAME into :NEWFLAGS separated by " "
from dictionary.columns
where libname = "WORK" and memname = "SAMPLEPROC1" and
 upcase(NAME) contains "_FLAG";
quit;

array newfl {*} &newflags.;
```

### Carry over values

```
array visit{*} visit_:;
 do i=2 to dim(visit);
  if missing(visit{i}) then visit{i} = visit{i-1};
 end;
```

### Summary sums

```
PROC SUMMARY DATA=wide;
	VAR Measure1-Measure4;
	OUTPUT OUT=sums(DROP = _type_ _freq_)
	SUM = Sum1-Sum4;
RUN;
/*********************************/
/*********************************/
DATA sums;
	SET wide END=last;
	ARRAY _measure{*} measure1-measure4;
	ARRAY _sum{*} Sum1-Sum4;
	KEEP sum1-sum4;
	DO i = 1 TO 4;
	 _sum{i} + _measure{i};
	 end;
	IF last THEN OUTPUT;
RUN; 


%MACRO selectsums(maxindex=);
	%DO n = 1 %TO &maxindex;
		SUM(measure&n) as Sum&n
		%IF &n NE &maxindex %THEN ,
		;
	%END;
%MEND selectsums; 
PROC SQL;
	CREATE TABLE sums AS
	SELECT %selectsums(maxindex=4)
	FROM wide
	;
QUIT;
```



## Retain

### Generate Serial Number

```
data abcd;
input x y;
cards;
1 25
1 28
1 27
2 23
2 35
2 34
3 25
3 29
;
run;
data aaa;
	set abcd;
	retain z 0;
	z = z + 1;
run;

***Cumulative Score;
data aaa;
  set abcd;
  retain z 0;
  z = z + y;
run;

***Generate Serial Number by Group;
proc sort data = abcd; by x; run;
data aaa;
  set abcd;
  retain z;
  if first.x then z = 1;
  else z = z + 1;
  by x;
run;
``` 
 


### Change from Basilne

```
data data_a;																	
			set data_b;
			by RD_IOL_TYP subject_id eye Visit;		

	        *** calculate the CFB and CFM1;
			retain baseline baseline2;
			if first.eye then do;
				baseline = .;
				baseline2=.;
			end;

			if first.eye and &var. ne . then do;
				if Visit = 1 then baseline = &var.;
			end;

			if VISIT = 5 and &var. ne . then do;
				baseline2 = &var.;
			end;

			if &var. ne . then do;
				if baseline ne . or baseline2 ne .  then do;
					if VISIT = 5 and baseline ne .  then CFB1  = &var. - baseline;
					*** split CFB off, better for report;
					if VISIT = 6 and baseline ne .  then CFB2  = &var. - baseline;				
					if VISIT = 6 and baseline2 ne . then CFM1  = &var. - baseline2;
				end;
			end;
			keep RD_IOL_TYP subject_id eye visit &var. CFB1 CFB2 CFM1 ITT PP;
run;
```


## Names and Types

### Convert all numeric to char*

```
/*** macro to convert all numeric to char ***/
%macro vars(ds_in, ds_out);
  %let list=;
  %let type=;
  %let dsid=%sysfunc(open(&ds_in));
  %let cnt=%sysfunc(attrn(&dsid,nvars));
   %do i = 1 %to &cnt;
    %let list=&list %sysfunc(varname(&dsid,&i));
    %let type=&type %sysfunc(vartype(&dsid,&i));
   %end;
  %let rc=%sysfunc(close(&dsid));
  data &ds_out(drop=
    %do i = 1 %to &cnt;
     %let temp=%scan(&list,&i);
       _&temp
    %end;);
   set &ds_in(rename=(
    %do i = 1 %to &cnt;
     %let temp=%scan(&list,&i);
       &temp=_&temp
    %end;));
    %do j = 1 %to &cnt;
     %let temp=%scan(&list,&j);
   /** Change C to N for numeric to character conversion  **/
     %if %scan(&type,&j) = N %then %do;
   /** Also change INPUT to PUT for numeric to character  **/
      ***&temp=PUT(_&temp,8.);
	  &temp=strip(vvalue(_&temp));
     %end;
     %else %do;
      &temp=_&temp;
     %end;
    %end;
  run;
%mend vars;

%vars(VENUS_L12_2_4_1_D02, VENUS_L12_2_4_1_D03)
```

### Get all the numeric variable names

```
proc transpose data=VENUS_L12_2_4_1_D02(obs=0) out=charvars;
 var _character_;
 run;
proc transpose data=VENUS_L12_2_4_1_D02(obs=0) out=numvars;
 var _numeric_;
 run;

proc sql noprint;
 select _name_ into :charvars separated by ' '
 from charvars;
 select _name_ into :numvars separated by ' '
 from numvars;
 quit;
 run;

%put NOTE: CHARVARS=&charvars;
%put NOTE: NUMVARS=&numvars;

proc sql noprint;
 select sub_reference into :subnum1 - :subnum4
 from VENUS_T8_2_3_6_D03a_sub;
 select sub_reference into :subnum separated by ',' 
 from VENUS_T8_2_3_6_D03a_sub;
 quit;
run;
%put &subnum1.;
%put &subnum.;
```

**Alternative**

```
data want_num(keep=_NUMERIC_) want_char(keep=_CHARACTER_);
    set SASHELP.class;
run;
proc sql;
  create table char as
    select *
      from sashelp.class (keep=_char_)
  ;
  create table num as
    select *
      from sashelp.class (keep=name _numeric_)
  ;
quit;
```
 


### Write all variable names as macro variables

Concatenate multiple cols into a single value

```
%macro M_VariableName_Content (ds_in, name, count_var, dataset_var); 
%macro HL; %mend HL;

%global &&count_var.;
%global &&dataset_var.;

proc contents data = &ds_in. out = &ds_in._content noprint; run;
proc sort data = &ds_in._content
    out = &ds_in._content (keep = &NAME.);
    by VARNUM;
run;

*** count the number of variable;
data _null_; 
    set &ds_in._content end=eof;
    retain counter 0;
    counter = counter + 1;
    if eof then call symputx("&count_var.", counter);
run;

proc transpose data = &ds_in._content out = &ds_in._content; var &NAME.; run;
data &ds_in._content;
    length concat $1000.;
    set &ds_in._content;
    concat = catx(" ", of COL1-COL&n_col_count.);
    call symput("&dataset_var.", concat);
run;

proc datasets library=work;
   delete &ds_in._content;
run;

%mend M_VariableName_Content;
```


**Alternative**: creating a long list of variable names based on an abbreviated one 

```
/***************************************************
   slist: an abbreviated list of variable names
          can be any SAS variable list
   flist: a global macro variable that is the
          expanded variable name list
***************************************************/
%macro varlist(data, slist);
  data _tiny_;
    set &data;
	keep &slist;
  run;
proc sql noprint;
  select name into :myvarlist separated by " "
  from sashelp.vcolumn
  where libname="WORK" and memname="_TINY_";
quit;
%let flist = &myvarlist;
%mend;
data test;
  array v(10);
  do j = 1 to 5;
  do i = 1 to 10;
    v(i) = i*5*j;
	ind = (i*j >30);
	end;
  output;
  end;
run;
%global flist;
%varlist(test, v:);
%put &flist;

################################
%put &flist;
v1 v2 v3 v4 v5 v6 v7 v8 v9 v10
```

### Write all observations as macro variable

```
*** Alternative1;
data _null_;
	set sashelp.class;
	suffix=put(_n_,5.);
	call symput(cats('Name',suffix), Name);
run;

*** Alternative2;
proc sql noprint;
	select Name
	into :Name1-:Name19
	from SAShelp.class;
quit;

*** Alternative3;
proc sql noprint;
	select count(*)
	into :NObs
	from SAShelp.class;
	select Name
	into :Name1-:Name%left(&NObs)
	from SAShelp.class;
quit; 

*** do a separate analysis for each macro variabe;
%macro doit;
	%do i=1 %to &NObs;
		%put # # # Processing &&Name&i # # #;
		%* ---- Analysis Code Goes Here ----- *;
	%end;
%mend;
%doit;


MANY MACRO VARIABLES
data _null_;
	set sashelp.class;
	suffix=put(_n_,5.);

	array xxx{*} _numeric_;
	do i =1 to dim(xxx);
	  *** VNAME returns the name of the specified variable;
	  call symput(cats(vname(xxx[i]),suffix),xxx[i]);
	end;

	array yyy{*} $ _character_;
	do i =1 to dim(yyy);
	  call symput(cats(vname(yyy[i]),suffix),yyy[i]);
	end;
run; 
%put &weight1;


%macro doit;
%let id=%sysfunc(open(sashelp.class));
%let NObs=%sysfunc(attrn(&id,NOBS));
%syscall set(id);
%do i=1 %to &NObs;
 %let rc=%sysfunc(fetchobs(&id,&i));
 %put # # # Processing &Name # # #;
 %* ---- Analysis Code Goes Here ----- *;


 %end;
%let id=sysfunc(close(&id));
%mend; 
```


### Select Character and numeric variables

```
proc sql noprint;
  select  distinct NAME 
  into    :NUM_LIST separated by ","
  from    DICTIONARY.COLUMNS
  where   LIBNAME="SASHELP"
    and   MEMNAME="CLASS"
    and   TYPE="num";
  select  distinct NAME 
  into    :CHAR_LIST separated by ","
  from    DICTIONARY.COLUMNS
  where   LIBNAME="SASHELP"
    and   MEMNAME="CLASS"
    and   TYPE ne "num";
  create table WANT_NUM as
  select  &NUM_LIST.
  from    SASHELP.CLASS;
  create table WANT_CHAR as
  select  &CHAR_LIST.
  from    SASHELP.CLASS;
quit;
/*** Oder ***/
data want_num(keep=_NUMERIC_) want_char(keep=_CHARACTER_);
    set SASHELP.class;
run;
proc sql;
  create table char as
    select *
      from sashelp.class (keep=_char_)
  ;
  create table num as
    select *
      from sashelp.class (keep=name _numeric_)
  ;
quit;
```


### Rename some variables

```
data faminc;
  input famid faminc1-faminc12 ;
cards;
1 3281 3413 3114 2500 2700 3500 3114 -999 3514 1282 2434 2818
2 4042 3084 3108 3150 -999 3100 1531 2914 3819 4124 4274 4471
3 6015 6123 6113 -999 6100 6200 6186 6132 -999 4231 6039 6215
;
run;

%macro rename1(oldvarlist, newvarlist);
  %let k=1;
  %let old = %scan(&oldvarlist, &k);
  %let new = %scan(&newvarlist, &k);
     %do %while(("&old" NE "") & ("&new" NE ""));
      rename &old = &new;
	  %let k = %eval(&k + 1);
      %let old = %scan(&oldvarlist, &k);
      %let new = %scan(&newvarlist, &k);
  %end;
%mend;

data a ;
  set faminc;
  %rename1(faminc1 faminc2, a b);
run;

proc print data = a heading= h noobs;
run;
```

### Rename with suffix

```
data faminc;
  input famid faminc1-faminc12 ;
cards;
1 3281 3413 3114 2500 2700 3500 3114 -999 3514 1282 2434 2818
2 4042 3084 3108 3150 -999 3100 1531 2914 3819 4124 4274 4471
3 6015 6123 6113 -999 6100 6200 6186 6132 -999 4231 6039 6215
;
run;

%macro rename2(oldvarlist, suffix);
  %let k=1;
  %let old = %scan(&oldvarlist, &k);
     %do %while("&old" NE "");
      rename &old = &old.&suffix;
	  %let k = %eval(&k + 1);
      %let old = %scan(&oldvarlist, &k);
  %end;
%mend;

data a ;
  set faminc;
  %rename2(faminc1 faminc2, _new);
run;
proc print data = a heading= h noobs;
run;
```



### Rename array variables

```
data faminc;
  input famid faminc1-faminc12 ;
cards;
1 3281 3413 3114 2500 2700 3500 3114 -999 3514 1282 2434 2818
2 4042 3084 3108 3150 -999 3100 1531 2914 3819 4124 4274 4471
3 6015 6123 6113 -999 6100 6200 6186 6132 -999 4231 6039 6215
;
run;

%macro rename3(oldprefix, newprefix, num);
  %let k=1;
     %do %while(&k <= &num);
      rename &oldprefix.&k  = &newprefix.&k;
	  %let k = %eval(&k + 1);
  %end;
%mend;

data a ;
  set faminc;
  %rename3(faminc, oldfaminc, 11);
run;
proc print data = a heading= h noobs;
run;
```




## Data utilities

### %Scan

Scan function: scan(s,n,"char") means to extract the nth string from the string string with char as the delimiter, syntax (syntax)

* scan(s,n) When n is a positive number, extract n characters from the end of the character s
* scan(s,n) When n is a negative number, extract n characters from the character s
* scan(s,n<,list-of-delimiters>)
    + If a delimiter is specified, only the delimiter will be extracted.
    + If not specified, it will be split according to the commonly used delimiter. The default delimiter is: space. <(+ &! $ *); ^-/,% | etc. or a combination

```
%macro VAC;
%MACRO HL;*** Enable editor code highlighting, delete when finalising; %MEND HL;
	%do i = 1 %to 2;
	%let va_cat = CDVA CDVA_dec;
	%let var =&i.;
	%let va = %SCAN (&va_cat, &var);
		data VENUS_T8_2_3_4_5_D01;
			set VENUS_T8_2_3_4_5_D01;
			by subject_id eye visit ;
            
			*** generate baseline CDVA CDVA_dec;
			retain base_&va. ;
			if first.eye then base_&va. = .;
			if first.eye and &va. ne . then do;
				if VISIT eq 1 then base_&va. = &va.;
			end;

	%end;run;
%mend VAC;
%VAC;
```

```
%macro mylogit1(all_deps);
  %let k=1;
  %let dep = %scan(&all_deps, &k);
  %do %while("&dep" NE "");
    title "dependent variable is &dep";
    proc logistic data=xxx des;
      model &dep = ind1 ind2;
    run;
    %let k = %eval(&k + 1);
    %let dep = %scan(&all_deps, &k);
  %end;
%mend;

*run the program for the first three v's;
%mylogit1(v1 v2 v3)


%macro mylogita(indata, all_deps, indvars =, myout =_out );
  %let k=1;
  %let dep = %scan(&all_deps, &k);
  %do %while(&dep NE);
    title "The dependent variable is &dep";
    title2 "The independent variables are &indvars";
    proc logistic data=&indata des outest=est&k;
      model &dep = &indvars;
    run;
    %let k = %eval(&k + 1);
    %let dep = %scan(&all_deps, &k);
  %end;
  data &myout;
    set 
    %do i = 1 %to &k - 1;
      est&i
    %end; 
    ;
  run;
%mend;
*run the program;
%mylogita(xxx, v1 v2 v3, indvars = ind1 ind2, myout = myparms)

title;
proc print data = myparms;
  var _name_ intercept ind1 ind2;
run;
```


### %eval and %syseval

The %SYSEVALF function performs floating-point arithmetic and returns a value that is formatted using the BEST32. format.

```
%let k = 1;
%let tot = &k + 1;
%put &tot;
1 + 1

%let tot = %eval(&k + 1);
%put &tot;
2

%let tot = %sysevalf(&k + 1.234);
%put &tot;
2.234


%let a = 2; 
%let b = 2.1;
%put The result with SYSEVALF is: %sysevalf(&a + &b);
%put BOOLEAN conversion: %sysevalf(&a + &b, boolean);
%put INTEGER conversion: %sysevalf(&a + &b, integer);
%put CEIL conversion: %sysevalf(&a +&b, ceil);
%put FLOOR conversion: %sysevalf(&a +&b, floor);
```

### Macro variable status

* %SYMEXIST: Used to judge whether a macro variable exists, and its parameter is the name of the macro variable. If the macro variable exists, it returns 1; otherwise, it returns 0.


      %let a1=1;
      %let re1=%symexist(a1);
      %let re2=%symexist(a2);
      %put re1=&re1 re2=&re2;

* %SYMGLOBL: Used to determine whether a macro variable is a global macro variable

**Check Macro Variable**

The DEFINED macro returns a value of 0 (false) if the argument is the name of a non-existent macro variable. It returns a 1 if the macro variable exists in the global macro environment.

```
*MVAR The name of a macro variable;
%macro defined (mvar);
  %local dsid rc scope;
  	/** Open the vmacro view which contains info about macor vars **/
  %let dsid=%sysfunc(open(sashelp.vmacro (where=(name="%upcase(&mvar)"))));
  	/** Fetch a record into the pdv if it exists **/
  %let rc=%sysfunc(fetch(&dsid));
  	/** Return varnum 1, the scope **/
  %let scope = %sysfunc(getvarc(&dsid,1));
  	/** Close the view **/
  %let rc=%sysfunc(close(&dsid));
  %if &scope = GLOBAL %then 1; %else 0;
%mend;

%global test;
%let test=3;

%macro testit;
	%if %defined(test)
	%then %put TEST is defined as &test;
	%else %put TEST is undefined;
%mend;

%testit;
```

* %SYSMACEXIST: used to judge whether a macro program exists in the Work.SASMacr catalog, if it exists, it returns 1, otherwise it returns 0.


### %SYSFUNC

 %SYSFUNC allows one to perform nearly ever SAS function on one's macro variables.
 
```
%macro procA;
 &
%mend procA;
%macro procB;
 D
%mend procB;

%let D = TEST;
%let C=%nrstr(%procB);
%let X=%str(%procA&C); 

%put Y1 = %sysfunc(substr(&X, 1));
%put Y3 = %sysfunc(substr(&X, 3));


*** Solution;

%procA = &
%procB = D
&D     = TEST
&C     = %nrstr(%procB) = %procB (not soloved)
&X     = %str(%procA&C) = %procA&C (soloved) =  &%procB

Y1 = %sysfunc(substr(&X, 1)) = %sysfunc(substr(&%procB, 1)) = &%procB = &D
Y3 = %sysfunc(substr(&X, 3)) = %sysfunc(substr(&%procB, 3)) = procB
```

### Quoting Function

%STR、%NRSTR、%QUOTE、%NRQUOTE、%BQUOTE、%NRBQUOTE、%SUPERQ、%UNQUOTE、%QSAN、%QSUBSTR、%QSYSFUNC、%QUPCASE

<!-- 用于屏蔽一些字符的特定功能，将其作为普通的字符来对待。例如：运算符、比较符、操作符灯，还有两个Macro Trigger：%，&。 -->


### Call Symput

The Symput and symget functions can pass information to or from the data step. When we want to get the information in the data step, there are two functions that are particularly useful. You can use symput to get the information in the data step into the macro variable, and when we want to get the information from the data in the macro variable into the data step, we will use symget.

<!-- Symput和symget函数可将信息传递到数据步骤或从数据步骤传递信息 当我们想获取数据步骤中的信息时，
有两个功能特别有用。可以使用symput将数据步骤中的信息获取到宏变量中，
而当我们希望将信息从宏变量中的数据获取到数据步骤中时，将使用symget。 -->

* Call symput — call symput(‘new_macro_variable’, value_in_string_format)
* Call symputx () will remove the spaces before and after the second parameter value
* symget —symget(‘macro_variable’)
 
#### Populating Macro Variables

```
data _NULL_; 
	set VENUS_analysis_sets_subj(where=(RD_IOL_TYP=1))  end=eof; 
	if eof then call symputx('n_SESsubj_Lara',  _n_); 
run; 
%put &n_SESsubj_Tecn.;



*** A set of Macro Variables;
data Venus_t8_2_3_5_2_Num;
  merge Venus_t8_2_3_5_2_Means
        Venus_t8_2_3_5_2_Num_cat;
  by analysis_set RD_IOL_TYP subgroup visit;

     if RD_IOL_TYP=1 then Treatment="LARA";
     if RD_IOL_TYP=2 then Treatment="TECN";

	   if N = . then N = 0;

     Name = "Num"|| "_" ||trim(Analysis_set)|| "_" ||trim(Treatment)|| "_" ||strip(subgroup)|| "_" ||put(visit,1.);

    do _N_=1 to 240;
     call symputx(Name,  N);
    end;

run;
```

#### SQL into

```
/*** Using SQL ***/
/*** One Macro Variable ***/

PROC SQL;
RESET NOPRINT;
SELECT PUT(MEAN(height),4.1)
INTO : avgheight
FROM sashelp.class
;
RESET PRINT;
%PUT macro variable AVGHEIGHT: [&avgheight]; 


/*** Two Macro Variables ***/

PROC SQL;
SELECT MAX(height),  MIN(height)
INTO : max_height , : min_height
FROM sashelp.class
;
QUIT;
%PUT macro variable MAX_FNAME: [&max_height];
%PUT macro variable MIN_FNAME: [&min_height];


/*** More Variables ***/

proc sql noprint;
   select name, Population 
      into :country1 - :country4, :pop1 - :pop3
           from sql.countries;

%put &country1 &pop1;
%put &country2 &pop2;
%put &country3 &pop3;
%put &country4;


/***Create macro variable in string***/
DATA _NULL_;
	SET thirteens END=done;
	LENGTH fname_string $ 9999;
	RETAIN fname_string;
	fname_string = CATX(' / ',fname_string,fname);
	IF done THEN CALL SYMPUT('fnames',TRIM(fname_string) );
RUN;
%PUT FNAMES: [&fnames]; 
/*** Outpuit: FNAMES: [Alice / Barbara / Jeffrey] ***/
PROC SQL;
SELECT fname
INTO : fnames SEPARATED BY ' / '
FROM thirteens
;
QUIT;
%PUT FNAMES: [&fnames];
```


### Call Execute

#### data null

Good way to replease  %IF %THEN statements, %IF %THEN statements cannot appear in open code. These statements are legal but only within a macro definition

```
%if &city = Boston %then %do;
proc means data=beantown;
var pahk youh caah;
run;
%end;
%else %if &city = New York %then %do;
proc means data=big_apple;
var a nominal egg;
run;
%end;




/*CALL EXECUTE is a DATA step statement that means: “Run this code.” */
ods html;
data sales;
 call execute ('proc print data=sales; run;');
 amount=5;
run;

data _null_;
  set sales end=nomore;
  total + amount;
  if nomore;
  if (total < 1000000) then call execute('		
    proc means data=sales;
    class state;
    var amount;
    title "Sales by State";
    run;
  ');
  else call execute('
    proc means data=sales;
    class state year;
    var amount;
    title "Sales by State and Year";
    run;
  ');
run;
```


#### Split the datasets

```
data _null_;
 set sashelp.class;
 call execute('data work.'||strip(name)||';
               set sashelp.class;
               where name="'||strip(name)||'";
               run;');
run;
/*First observation with name Alfred*/
data work.Alfred;
 set sashelp.class;
where name="Alfred";
run;
/*Second observation with name Alice*/
data work.Alice;
 set sashelp.class;
 where name="Alice";
run;

/*Alternative 1*/
%macro datasets(name= );
 data work.&name;
 set sashelp.class;
 where name="&name";
 run;
%mend datasets;
data _null_;
 set sashelp.class;
 call execute('%datasets(name='||strip(name)||');');
run;




/*Alternative 2*/
proc sql;
 create table work.Vars as
 select name,type
 from dictionary.columns
 where memname="CLASS" and libname="SASHELP";
quit;
%macro report(var= , type= );
 %if &type=char %then %do;
 proc freq data=sashelp.class;
 table &var;
 run;
 %end;
 %else %do;
 proc means data=sashelp.class;
 var &var;
 run;
 %end;
%mend report;
data _null_;
 set work.Vars;
 call execute('%report(var='||strip(name)||' , type='||strip(type)||');');
run;
/*Code generated and executed by Call Execute:*/
%report(var=Age ,    type=num);
%report(var=Sex ,    type=char);
%report(var=Age ,    type=num);
%report(var=Height , type=num);
%report(var=Weight , type=num);
```


#### SYMGET

CALL EXECUTE cannot change the currently executing DATA step. By using SYMGET, it is actually possible to work around that limitation

```
%let pet="CAT";
data test;
 call execute ('%let pet=DOG;');
 animal = &pet.;
 put animal;  
run;
 
%let pet=CAT;
data test;
 call execute ('%let pet=DOG;');
 animal = symget('pet');
 put animal;  
run;


%let value = BEFORE;
data _null_;
  call symput('value', 'AFTER');
  /* Double quotes permit resolution of &VALUE during the initial phase of the DATA step*/
  /* Double Quotes: value is BEFORE.*/
  call execute("%put Double Quotes: value is &VALUE..;");
  call execute('%put Single Quotes: value is &VALUE..;');
run;
```

### Dummy Datasets

#### Creating dummy datasets from tables freq

```
data ds;
	female = 0; homeless = 1; count = 169; output;
	female = 1; homeless = 1; count = 40; output;
	female = 0; homeless = 0; count = 177; output;
	female = 1; homeless = 0; count = 67; output;
run;

proc freq data = ds;
	table homeless * female;
	weight count;
run;

data newds;
	set ds;
	do i = 1 to count;
	  output;
	end;
run;

proc freq data = newds;
	table homeless * female;
run;
```

#### %Expgrid: Create a data set from all combinations of factors

```
%macro expgrid/parmbuff;

%local out;
%let out = _grid_;   %*-- Name of output data set;

%*-- Process the variable arguments, each of the form
      VAR = val1 val2 val2 ...,   (delimited by commas)
	or VAR = val1 TO val2 BY val3,
	Create macro variables &&VAR1, &VAR2, ... (Variable names)
	and &VAL1, &VAL2, ... (Variable values)
;
%local narg arg;
%let narg = 1;
%let arg = %scan(&syspbuff, &narg, %str((,)));
%do %while(%quote(&arg) ^= );
	%if %length(&arg) > 0 %then %do;
		%let arg&narg = &arg;
		%let var&narg = %scan(&arg, 1, =);
		%let val&narg = %trim(%scan(&arg, 2, =));
		%*put ARG&narg = &arg  VAR&narg=&&var&narg  VAL&narg=|&&val&narg|;
		%end;
	%let narg=%eval(&narg+1);
	%let arg=%scan(&syspbuff, &narg, %str((,)));
	%end;
%let narg=%eval(&narg-1);
%*put NARG=&narg;

data &out;
	%*-- Generate the DO statements;
	%do i = &narg %to 1 %by -1;
		%if %index(%upcase(&&val&i, %str( TO ))) %then %do;
			do &&var&i = &&val&i;
			%end;
		%else %do;
			%*-- Handle lists;
			%if %verify(&&val&i,%str(0123456789. )) ^= 0 %then %do;
				length &&var&i $8;
				%end;
			do &&var&i = %dolist(&&val&i)
			;
		%end;
	%end;

		output;

	%*-- Generate the END statements;
	%do i = 1 %to &narg;
		end;
		%end;
run;
%mend;

%*-- Translate a simplified do-list to a syntactically correct one, e.g., 
	3 4 5 -> 3,4,5
 or Male Female -> 'Male', 'Female'
;
%macro dolist(arg, split=%str( ), sep=%str(,));
	%local val i j max return;
	%let return=;
	%let max=%count(&arg, split=&split);
   %do i=1 %to &max;
		%let val=%scan(&arg, &i, &split);
		%if %verify(&val,0123456789.) ^= 0 %then %do;
			%let val = "&val";
			%end;
		%if &i=&max %then %let return=&return.&val;
		%else %let return=&return.&val.&sep;
	%end;
%unquote(&return)
%mend;

%*-- Count 'words' in a string, delimited by split;
%macro count(arg, split=%str( ));

%local i;
%let i=0;
%do %while(%length(%nrbquote(%scan(&arg, &i+1, &split))));
	%let i=%eval(&i+1);
%end;
&i
%mend;


%expgrid(n=1 to 2, trials=2 4 8, time=10 to 20 by 5, sex=Male Female);

* generates the data step;

data _grid_;
	do sex='Male  ', 'Female';
		do time= 10 to 20 by 5;
			do trials=2, 4, 8;
				n = 1 to 2;
				output;
			end;
		end;
	end;
run;
```


### Dummy variables with reference

Given a character or discrete numeric variable, the DUMMY macro will create a dummy (0/1) variable to represent the level of the original variable in the regression model. If the original variable has c levels, (c-1) new variables will be generated (or, if FULLRANK = 0, then c variables)

| Var       |  Des.                                                                                                                                                                                                                                                                                                                                  |
|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| DATA=     | The name of the input dataset. If not specified, the most recently created dataset is used.                                                                                                                                                                                                                                            |
| OUT=      | The name of the output dataset. If not specified, the new variables are appended to the input dataset.                                                                                                                                                                                                                                 |
| VAR=      | The name(s) of the input variable(s) to be dummy coded. Must be specified. The variable(s) can be character or numeric.                                                                                                                                                                                                                |
| PREFIX=   | Prefix(s) used to create the names of dummy variables. The default is 'D_'.                                                                                                                                                                                                                                                            |
| NAME=     | If NAME=VAL, the dummy variables are named by appending the value of the VAR= variable to the prefix. Otherwise, the dummy variables are named by appending numbers, 1, 2, ... to the prefix. The resulting name must be 8 characters or less.                                                                                         |
| BASE=     | Indicates the level of the baseline category, which is given values of 0 on all the dummy variables. BASE=FIRST specifies that the lowest value of the VAR= variable is the baseline group; BASE=LAST specifies the highest value of the variable. Otherwise, you can specify BASE=value to make a different value the baseline group. |
| FULLRANK= | 0/1, where 1 indicates that the indicator for the BASE category is eliminated.                                                                                                                                                                                                                                                         |

```
%macro dummy( 
   data=_last_ ,    /* name of input dataset                  */
   out=&data,       /* name of output dataset                 */
   var= ,           /* variable(s) to be dummied              */
   base=_last_,     /* base category                          */
   prefix = D_,     /* prefix for dummy variable names        */
   format =,        /* format used to categorize variable     */
   name  = VAL,     /* VAL: variable names are D_value        */
   fullrank=1       /* Eliminate dummy for baseline category? */
   );

	%let abort = 0;
   %if (%length(&var) = 0) %then %do;
       %put ERROR: DUMMY: VAR= must be specified;
		 %let abort=1;
       %goto done;
       %end;

%let base = %upcase(&base);
%let name = %upcase(&name);

%if %upcase(&data) = _LAST_ %then %let data = &syslast;
%if %upcase(&data) = _NULL_ %then %do;
	%put ERROR: There is no default input data set (_LAST_ is _NULL_);
	%let abort=1;
	%goto DONE;
	%end;
	
options nonotes;

%*-- Initialize output data set;
%if &out ^= &data %then %do;
	data &out;
		set &data;
	%end;
	
%let prefix = %upcase(&prefix);

%*-- j indexes variables, vari is the current variable name;
%local j vari;
%let j=1;
%*-- Find the current variable name;
%let vari= %scan(&var,    &j, %str( ));

%******************************************************************;
%*-- Loop over variables; 
%******************************************************************;
%do %while(&vari ^= );

	%*-- Find the current prefix for dummies;
	%let pre = %scan(&prefix, &j, %str( ));
	%if &pre = VARNAME | &pre = %then %let pre=&vari._;
	%*-- Keyword BLANK for prefix indicates no prefix;
	%if &pre=BLANK %then %let pre=;

	%*-- Find the current base for dummies;
	%let baseval = %scan(&base, &j, %str( ));
	%if &baseval = %then %let baseval=_LAST_;

	%*-- Find the current format for dummies;
	%let fmt = %scan(&format, &j, %str( ));

*-- determine values of variable to be dummied;
proc summary data = &out nway ;
     class &vari ;
     %if %length(&fmt) gt 0 %then %do;
	  		%*-- Make sure format name includes a '.';
        %if "%substr(&fmt, %length(&fmt))" ne "." 
		  		%then %let fmt = &fmt..;
        format &vari &fmt;
     %end;
     output out = _cats_ ( keep = &vari ) ;
	%if &syserr > 4 %then %let abort=1; 
	%if &abort %then %goto DONE;

	%if &fullrank %then %do;
	*-- Eliminate the base category;
	data _cats_;
		set _cats_ end=_eof_;
		%if &baseval = _FIRST_ | &baseval = LOW 
			%then %str( if _n_ = 1 then delete;);
		%else %if &baseval = _LAST_ | &baseval = HIGH
			%then %str( if _eof_ then delete;);
		%else %str(if &vari = &baseval then delete;);
	run;
	%end;

data _null_ ;
 set _cats_ nobs = numvals ;

 if _n_ = 1 then do;
	%*-- If there are no non-baseline values - abort macro; 
	call symput('abort',trim( left( put( (numvals=0), best. ) ) ) ) ;
	%*-- Place number of dummies into macro variable num;
	call symput( 'num', trim( left( put( numvals, best. ) ) ) ) ;
	end;

	%*-- Number the values, place in macro variables c##; 
	%if %length(&fmt) gt 0 %then %do;
		call symput ( 'c' || trim ( left ( put ( _n_,     best. ) ) ),
								trim(left(put(&vari,&fmt)) ) );
	%end;
	%else %do;
	call symput ( 'c' || trim ( left ( put ( _n_,     best. ) ) ),
								trim ( left ( &vari ) ) ) ;
	%end;
run ;
%if &syserr > 4 %then %let abort=1; %if &abort %then %goto DONE;

%******************************************************************;
%* Create list of dummy variables for the j-th input variable;
%******************************************************************;

%if "&name" = "VAL" %then %do ;
	%*-- Names by variable value;
	%let vl&j =; 
	%do k=1 %to &num;
		%if %sysevalf(&sysver  < 7 & %length(&pre&&c&k) > 8) %then %do;
			%put ERROR: Cannot generate names longer than 8 characters;
			%let abort=1;
			%goto DONE;
			%end;
		%let vl&j = &&vl&j  &pre&&c&k;
		%end; ;
%*put vl&j = &&&vl&j;

data &out;
	set &out ;
	
	array __d ( &num ) %do k=1 %to &num ;	&pre&&c&k
							%end ; ;
	%put DUMMY: Creating dummy variables &pre&&c1 .. &pre&&c&num for &vari;
	%end ;

%else %do ;
	%*-- Numeric suffix names;
	%let vl&j =; 
	%do k=1 %to &num; 
		%if %sysevalf(&sysver  < 7 & %length(&pre.&k) > 8) %then %do;
			%put ERROR: Cannot generate names longer than 8 characters;
			%let abort=1;
			%goto endloop;
			%end;
		%let vl&j = &&vl&j  &pre.&k;
		%end; ;
%*put vl&j = &&&vl&j;
run;
	
%******************************************************************;
%* Assign values to the dummy variables for the j-th input variable;
%******************************************************************;
data &out  ( rename = ( %do k=1 %to &num ;
						d&k = &pre.&k
						%end ; ) ) ;
	set &out ;
	%put DUMMY: Creating dummy variables &pre.1 .. &pre.&num;
	array __d ( &num ) d1-d&num ;
	%end ;

	%*---------------------------------------------------------;
   %*   Handle missing values (for V7+ only);
	%*-- (to do this for V6.12 requires separate processing for
	      character and numeric variables);
	%*---------------------------------------------------------;
	%if %sysevalf(&sysver  >= 7) %then %do;
     if missing(&vari) then do;
	  	 do j=1 to &num;
        __d(j)=.;
		  end;
		return;
     end;
	%end;

	%*---------------------------------------------------------;
   %*   Assign values to dummy variables;
	%*---------------------------------------------------------;
	drop j;
	do j = 1 to &num ; /* initialize to 0 */
		__d(j) = 0 ;
	end ;


     %if %length(&fmt) eq 0 %then %do;
     %*-- Case 1:  No format;
        if &vari = "&c1" then __d ( 1 ) = 1 ;  /* create dummies */
        %do i = 2 %to &num ;       
           else if &vari="&&c&i" then __d ( &i ) = 1 ;
        %end;
     %end;

     %else %do;
     %*-- Case 2:  with format;
        if put(&vari,&fmt) = "&c1" then __d ( 1 ) = 1 ;
        %do i = 2 %to &num ;       
           else if put(&vari,&fmt)="&&c&i" then __d ( &i ) = 1;
        %end;
     %end;
run ;

%*-- Find the next variable;

%let j=%eval(&j+1);
%let vari = %scan(&var, &j, %str( ));

%*put End of loop(&i): vari = &vari  pre=&pre;
%endloop:
%end;  /* %do %while */

%done:
%if &abort %then %put ERROR: The DUMMY macro ended abnormally.;
options notes;
%mend dummy ;


data test;
	input y group $ sex $ @@;
	cards;
	10  A M 12  A F 13  A M  18  B M 19  B M 16  C F 21  C M 19  C F 
;
proc format;
	value $sex 'M'='Male' 'F'='Female';
%dummy (data=test, var =sex group, format=$sex, prefix=blank varname);

proc print data = test; run;
```

$$
\begin{array}{|r|r|l|l|r|r|r|}
\hline \text { Obs } & \text { y } & \text { group } & \text { sex } & \text { Female } & \text { group_A } & \text { group_B } \\
\hline 1 & 10 & \mathrm{~A} & \mathrm{M} & 0 & 1 & 0 \\
\hline 2 & 12 & \mathrm{~A} & \mathrm{~F} & 1 & 1 & 0 \\
\hline 3 & 13 & \mathrm{~A} & \mathrm{M} & 0 & 1 & 0 \\
\hline 4 & 18 & \mathrm{~B} & \mathrm{M} & 0 & 0 & 1 \\
\hline 5 & 19 & \mathrm{~B} & \mathrm{M} & 0 & 0 & 1 \\
\hline 6 & 16 & \mathrm{C} & \mathrm{F} & 1 & 0 & 0 \\
\hline 7 & 21 & \mathrm{C} & \mathrm{M} & 0 & 0 & 0 \\
\hline 8 & 19 & \mathrm{C} & \mathrm{F} & 1 & 0 & 0 \\
\hline
\end{array}
$$




## Check for validation

### Check datasets exists

```
%macro exist（dsn=）；
　　%global exist；
　　%if %sysfunc（exist（&dsn．）） %then %let exist=YES；
　　%else %let exist=NO；
%mend exist；
%exist（dsn=Test）；
%put &exist.;
```

### Check datasets and Variables

```
%macro CheckDsVar(ds =, var =);
  %local dsid check rc;
  %let dsid = %sysfunc(open(&ds.));
  %if  &dsid=0 %then %DO; 
      %put  Warning: Dataset &ds. is not exist!;  
      %ABORT; 
  %END; 
  %else  %do;
	  %let check = %sysfunc(varnum(&dsid., &var.));
	  %let rc = %sysfunc(close(&dsid.));
	  %if &check. = 0 %then   %DO ;
          %put Warning: Variable &var is not exists!; 
          %ABORT; 
      %END;
	  %if &check. ne 0 %then   %DO ;
          %put Congratulations! Variable &var is exists!; 
      %END;
  %end;
%mend CheckDsVar;
%CheckDsVar (ds =sashelp.class, var=height);
```



### Check datasets if empty

```
*** Check if the dataset is empty;
proc sql;
	select count(*) into: nobs 
	from work.VENUS_T8_1_3_1_D01_&in.;
quit;
%put &nobs.;
```

Alternative

```
*** Check if table is empty;
%let dsid=%sysfunc(open(&ds.));
%let nobs=%sysfunc(attrn(&dsid.,nlobs));
%let dsid=%sysfunc(close(&dsid.));
%IF &nobs. eq 0 %then %do;
*** If table is empty, create dummy observation;
	data &ds.; 
		retain description order1 n_lara p_lara n_tecn p_tecn "";
		retain order1 0;
	run;
%END;
```

**Deal with empty in proc report**

```
	%if &nobs. eq 0 %then %do;
			compute after;
				line 'No device deficiencies occurred during this investigation.^n';
			endcomp;
		%end;
		%else %if &nobs. ne 0 %then %do;
     	compute before ;									
		line ' ';
	    endcomp;
	    compute after order1;
		line ' ';
	    endcomp;
		%end;
```

### %sysfunc get the observations

```
%macro getNobsOf(data);
proc sql noprint;
	select count(*) into: nobs
	from &data;
quit;
%mend;

%global nobs;
%getNobsOf(sashelp.class);
%put &nobs;



/* version 2 */
%macro getNobsOf(data); 
%local dsid;
%local nobs;
%local rc;

%let dsid = %sysfunc(open(&data));
%let nobs = %sysfunc(attrn(&dsid, nobs));
%let rc   = %sysfunc(close(&dsid));

&nobs
%mend getNobsOf;

%let nobs = %getNobsOf(sashelp.class);
%put &nobs;
```



## Log

### %LogReader

Automatic readout of the Log window and automatic storage of the Log as a txt-file.

read_txt: dataset including 

* string (Error/Warning/Note message) 
* type (Error, Warning or Note) 
* dataset step (data step in which the message has occurred) 
* Line (Number of the line ABOVE the message)

```

**********************************************************
*** define the Path_log and FileName, where the txt-file of Log Window 
*** should be saved
**********************************************************;
%let Path_log = Z:\CDISC\STUDIES\02_LogReader; /* adapt */
%let FileName = log_message.txt;  

**********************************************************
*** save the log to an external file
**********************************************************;
Dm 'log; print file = "&Path_log\&FileName" replace';

**********************************************************
*** The next DATA step is used to read in the newly created 
*** text file a line at a time scanning for keywords and DATA 
*** step names.
**********************************************************;
data read_txt;
	infile "&Path_log\&FileName" truncover lrecl= 200;
	length 	string1 $ 200 
			type 	$ 10
	;
	retain dsstep NewLine NewStr;
	input @1 string1 $char200.;

/* keep number of the line ABOVE the message */
	Line = substr(string1, 1, 5);	
	IntLine = input(Line,?? 5.);	*** converts the character value "Line" to integer;
									*** sets IntLine as missing, when "Line" is no number; 
										*** Caution: if "Line" is no number, "NOTE: Invalid argument to 
										function INPUT at line..." will be produced;
										*** ?? suppresses the above-named NOTE;

*	if Line notin (" ", "ERRO", "NOTE", "WARN") then do;
	if IntLine ne . then do;		
		NewLine = IntLine;
	end;

drop IntLine;

/* include data find, cut out, mark */
	Str = index(String1,"%include");
	if Str > 0 then do;
		NewStr = scan(string1, -1, "\");
		NewStr = scan(NewStr, 1, ".");
	end; 

***********************************************************
*** The DATA step name is stored as a field for ease of tracing 
*** back where in the code the NOTE or WARNING or ERROR message 
*** was found. To locate the DATA step name, the program looks 
*** for the word ‘data’ as the second word in each SAS statement 
*** excluding the lines that begin with NOTE, WARNING or ERROR. 
*** To compensate for any combination of mixed case spelling of 
*** ‘data’, the contents of the second string word is upcased before 
*** being stored in the DATA step name field and then evaluated for 
*** a word match. After the DATA statement is located, the starting 
*** position of the word ‘DATA’ is stored in the field ‘strt_txt’. 
*** This is necessary because log line numbers vary in length, which 
*** shift the starting position of the word ‘DATA’ in the DATA step statement
**********************************************************;
	If substr(string1,1,4) notin ('NOTE' 'WARNING' 'ERROR') then do;
		word = upcase(scan(string1,2));
	end;
	if word= 'DATA' then do;
		strt_txt= length(scan(string1,1)) + 1;
		dsstep = trim(left(substr(string1,strt_txt)));
	end;

************************************************************
*** The next statements are used to identify the keywords ERROR, WARNING 
*** or NOTE. In this code, all WARNING and ERROR messages were output for 
*** review. The NOTE line generated by SAS not only contains possible problems 
*** but informative SAS data and processing messages that we do not want to 
*** capture here
************************************************************;
	if substr(string1,1,5) ='ERROR' then do;
		type='ERROR';
		output;
	end;
	else if substr(string1,1,7) = 'WARNING' then do;
		type='WARNING';
		output;
	end;
	else if substr(string1,1,4) = 'NOTE' then do;
		note1=index(string1,'stopped');				*** NOTE: "The SAS System stopped processing this step because of errors;
		note2=index(string1,'converted');			*** NOTE: "Numeric values have been converted" 
														   or "Character values have been converted";
		note3=index(string1,'uninitialized');		*** NOTE: "… the variable … is uninitialized";
		note4=index(string1,'division by zero');	*** NOTE: "… division by zero detected";
		note5=index(string1,'Invalid');				*** NOTE: "… Invalid argument …"
												  		   or "… invalid data";
		note6=index(string1,'Missing');				*** NOTE: "Missing values were generated as a result of performing 
															  an operation on missing values";
		note7=index(string1, "is already on the library");	
													*** NOTE: "…is already on the library…";
		note8=index(string1, " 0 observations");		*** NOTE: "The data set .. has 0 observations and .. variables";
		note9=index(string1, " 0 variables");		*** NOTE: "…0 variables";
		note10=index(string1, "MERGE statement");	*** NOTE: "…MERGE statement…";
		note11=index(string1, "at least one W.D.");	*** NOTE: "… at least one W.D. …";
		note12=index(string1, "no statistics");		*** NOTE: "… no statistics are computed …";
		note13=index(string1, "overwritten");		*** NOTE: "… variable … on data set  … will be overwritten";
		note14=index(string1, "NOSPOOL");			*** NOTE: "NOSPOOL is on";
		note15=index(string1, "Mathematical");		*** NOTE: "Mathematical operations could not be performed... The results
															   of the operation have been set to missing values";
		note16=index(string1, "LOST CARD");			*** NOTE: LOST CARD;
		note17=index(string1, "new line");			*** NOTE: SAS went to a new line;
		note18=index(string1, "outside the axis range"); 	*** NOTE: …outside the axis range;


		if note1  gt 0 or note2  gt 0 or note3  gt 0 or note4  gt 0 or note5  gt 0 or 
		   note6  gt 0 or note7  gt 0 or note8  gt 0 or note9  gt 0 or note10 gt 0 or 
		   note11 gt 0 or note12 gt 0 or note13 gt 0 or note14 gt 0 or note15 gt 0 or 
		   note16 gt 0 or note17 gt 0 or note18 gt 0 then do;
		   type='NOTE';
		   output;
		end;
	end;
	drop note1-note18 strt_txt word Line Str;
	rename 	NewLine = Line
			NewStr = Include; 
run;
*ods html;
proc print data=Read_txt;
run;
*ods html close;
```

## Proc Transpose

### _numeric_

```
proc transpose data=have out=t;
by id name firmid;
var _numeric_;
run;
```

### In processing


## Clean Up

### Basic setting


**Cleaning OUTPUT SCREEN and LOG**

```
dm log "clear";
dm output "clear";
```
Alternatively, you can use a different DM statement that will not only clear the output screen but will also remove any leftover “residue” in the results window.

`dm ‘odsresults’ clear;`

**Cleaning LIBNAME references**

`libname &&new&i clear;`
 
**Cleaning TITLES and FOOTNOTES**

`title1; footnote1;`

### Delete datasets

**Deleting with PROC SQL**

```
proc sql;
drop table work.Venus_t8_2_3_9_2_d03_:,  work.Venus_t8_2_3_9_2_d04_:;
quit;
```

**Deleting with PROC DELETE**

```
proc delete data=work.Venus_t8_2_3_9_2_d03 work.Venus_t8_2_3_9_2_d04;
run;
```

**Deleting with PROC Datasets**

```
proc datasets lib=work nolist;
	delete Venus_t8_2_3_9_2_d03_: ;
quit;
```

**Delete All Data Sets from a Library**

```
proc datasets library=library-name kill nolist;
quit;
```

### Deleting Formats

**Delete Numeric Format**

```
proc format;
	value eye
		1 = "OD"
		2 = "OS";
	value visit
		1 ="Screening"
		2 ="Surgery"
		3 ="D1"
		4 ="W1"
		5 ="M1"
		6 ="M4-6"
		99 ="Unscheduled";
run;
	
proc catalog catalog=work.formats;
	delete visit.format  eye.format ;
run;
```

**Delete Character Format**

```
proc format;
	value $ enrolled 
		'n_Screened' = 'Screened'
		'n_enrolled' = 'Randomized'
		'n_screen_failure' = 'Randomization failure'
		'n_implanted_1' = '1^{super st} eye implanted'
		'n_implanted_2' = '2^{super nd} eye implanted'
		'n_One_eye_eligible' = 'Only one eligible eye'
		'n_SES' = 'Safety population'
		'n_ITT' = 'modified Intention to Treat population'
		'n_PP' = 'Per-protocol population^n'
		'n_completed_study' = 'Completed study'
		'n_discontinued' ='Discontinued^n'
		other=[$250.];		
run;


proc catalog catalog=work.formats;
	delete Enrolled.formatc;
run;
```

### Remove assigned formats

**format _all_ will delete all the formats in the SAS dataset.**

```
PROC DATASETS lib=work;
MODIFY dsn;
FORMAT _all_;
INFORMAT _all_;
RUN;
QUIT;
```

**remove only the formats and informats of specific variables in the SAS dataset.**

```
Proc DataSets Lib = Work;
Modify dsn;
Format heigt weight sex;
Run ;
Quit ;
```

**delete formats/informats of all character or numeric variables**

```
proc datasets lib=work;
modify dsn;
format _char_; *format _num_;
run;
Quit;
```


### Delete macro variables

```
%macro deleteALL;
   	options nonotes;
  	%local vars;
  	proc sql noprint;
      	     select name into: vars separated by ' '
         	  from dictionary.macros
            	      where scope='GLOBAL' 
			   and not name contains 'SYS_SQL_IP_' and not name contains ('STUDY') 
			   and not name contains ('REPORT') and not name contains ('SPONSOR')
			   and not name contains ('SYSRANDOM')
			   ;
   	quit;
 	%put &vars.;
   	%symdel &vars;
 
   	options notes;
   	%put NOTE: Macro variables deleted.;
 
%mend deleteALL;
```

**Alternative**

```
proc sql noprints;
    select name into:mymacrovars separated by ''
	from dictionary.macros
	where scope = 'GLOBAL';
quit;
%symdel &mymacrovars mymacrovars;
```

### Delete Macro

**With specifying the macro**

```
proc catalog cat=work.sasmacr;
    delete macro_name / et=macro;
quit;

proc catalog catalog = work.sasmacr kill force; run;
```

**Reset all %macro**

```
/****************************************************************************
Reset all %macro: Deletes a macro definition from the Work.SASMacr catalog.;

Use DELETE parameter to list macro names to delete.
Use KEEP parameter to list macro names to NOT delete.
Calling it with no values will delete all macros not currently running.
****************************************************************************/


%macro macdelete(delete,keep);

%local libname memname objname objtype fid i;
%do i=1 %to %sysmexecdepth;
  %let keep=%sysmexecname(&i) &keep;
%end;
%if %length(&delete) %then %let delete=and findw("&delete",objname,',','sit');
%let fid=%sysfunc(open( sashelp.vcatalg(keep=libname memname objname objtype
 where=(libname='WORK' and objtype='MACRO' and memname like 'SASMAC_'
   and not findw("&keep",objname,',','sit') &delete))));
%if (&fid) %then %do;
  %syscall set(fid);
  %do %while(0=%sysfunc(fetch(&fid)));
    %put %sysfunc(compbl(Removing &objname from &libname catalog &memname));
    %sysmacdelete &objname;
  %end;
  %let fid=%sysfunc(close(&fid));
%end;
%else %put %qsysfunc(sysmsg());
%mend macdelete;
%macdelete;

```
