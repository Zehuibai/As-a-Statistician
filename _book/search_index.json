[["cdisc.html", "Chapter 28 CDISC 28.1 Study Data Tabulation Model (SDTM) 28.2 SDTM SAS Macro 28.3 Analysis Data Model (ADaM) 28.4 ADaM SAS Macro 28.5 Project Example MEDIWOUND1", " Chapter 28 CDISC {r,echo = F,message = FALSE, error = FALSE, warning = FALSE} library(&#39;mindr&#39;) input &lt;- rstudioapi::getSourceEditorContext()$path mm(from = input, type = &#39;file&#39;, widget_name = &#39;28_CDISC.html&#39;, root = &quot;&quot;) The Clinical Data Interchange Standards Consortium (CDISC) is an open, non-profit organization covering a variety of disciplines. The Association is committed to developing industry data standards that provide electronic means for the acquisition, exchange, submission, and archiving of clinical trial data and metadata for the development of medical and biopharmaceutical products. 28.1 Study Data Tabulation Model (SDTM) 28.1.1 Introduction Study Data Tabulation Model (SDTM), which defines a standard structure for study data tabulations that are to be submitted as part of a product application to a regulatory authority such as the United States Food and Drug Administration (FDA). SDTMFDA Data tabulation datasets are one of four ways to represent the human subject Case Report Tabulation (CRT) and equivalent animal data submitted to the FDA. CRTs are also submitted in the format of subject profiles, data listings, and analysis datasets. One benefit to the industry of submitting data tabulation datasets that conform to the standard structure is that it minimizes the need to submit the same data in multiple formats. CRTFDA CRT The availability of standard submission data may provide many benefits to regulatory reviewers. Reviewers can now be trained in the principles of standardized datasets and the use of standard software tools, and thus be able to work with the data more effectively with less preparation time. Another benefit of the standardized datasets is that they can provide support for the FDAs efforts to develop a repository for all submitted studies and a suite of standard review tools to access, manipulate, and view the study data. FDA 28.1.2 Model Concepts and Terms 28.1.2.1 The concept of observations DTM1016  SDTM Identifier variables, such as those that identify the study, the subject (individual human or animal or group of individuals) involved in the study, the domain, and the sequence number of the record. Topic variables, which specify the focus of the observation (such as the name of a lab test). Timing variables, which describe the timing of observation (such as start date and end date). Qualifier variables, which include additional illustrative text, or numeric values that describe the results or additional traits of the observation (such as units or descriptive adjectives). Rule variables, which express an algorithm or executable method to define start, end, or looping conditions in the Trial Design model. 28.1.2.2 Domain-specific variables limited number of designated domains and will be identified in the appropriate implementation guide. The variable names include the specific domain prefix. SDTM v1.5 All datasets are structured as flat files with rows representing observations and columns representing variables. Each dataset is described by metadata definitions that provide information about the variables used in the dataset. The metadata are described in a data definition document named define that is submitted with the data to regulatory authorities. Define-XML specifies variable metadata attributes such as: name, label, data type, etc. The SDTM describes the name, label, role, and type for the standard variables.  define Define-XMLSDTM 28.1.3 SDTM Domains SDTMdomains Figure 28.1: Figure: SDTM domains (Interventions)(Events)(Findings)SDTM :  (CO)  (DM)  (SE)  (SV)   (CM)  (EC)  (EX)  (SU)  (PR)   (AE) (CE)  (DS) (DV)  (HO) (MH)   (DA)  (DD)  (EG) / (IE)  (IS)  (LB)  (MB)  (MI)  (MO)  (MS)  (PC)  (PP)  (PE)  (QS) (RP) / (RS)  (SC)  (SS)  (TU) / (TR)  (VS)   (FA)  (SR)   (TA) (TD)  (TE) (TV) (TI) (TS)   (SUPP)  (RELREC) 28.1.3.1 AE (Adverse Events) AE, (ICH E2A). ,sponsorAE(, ). AEprotocol. AE. AETERM(Reported Term for the Adverse Event):  AEMODIFY(Modified Reported Term): AETERM,  AEDECOD(Dictionary-Derived Term): , AETERMAEMODIFY. Preferred TermPT in MedDRA. AEPTCD(Preferred Term Code): AEDECOD AEHLT(High Level Term): System Organ ClassHigh Level Term AEHLTCD(High Level Term Code): AEHLT AEHLGT(High Level Group Term):System Organ ClassHigh Level Group Term AEHLGTCD(High Level Group Term Code): AEHLGT AECAT(Category for Adverse Event): . BLEEDING(), NEUROPSYCHIATRIC() AESCAT(Subcategory for Adverse Event): AE,  NEUROLOGIC() AELOC(Location of Event)L Event, (skin rash)(ARM) AESEV(Severity/Intensity): Event, MILD, MODERATE, SEVERE AESER(Serious Event): Even AEREL(Causality): . ICH E2AE2BNOT RELATED, UNLIKELY RELATED, POSSIBLY RELATED, RELATED. . AEOUT(Outcome of Adverse Event):  AESCAN(Involves Cancer): SAE AESCONG(Congenital Anomaly or Birth Defect): SAE AESDISAB(Persist or Signif Disability/Incapacity): SAE AESDTH(Results in Death): SAE AESHOSP(Requires or Prolongs Hospitalization): SAE AESLIFE(Is Life Threatening): SAE AECONTRT(Concomitant or Additional Trtmnt Given): ,  AESTDTC/AEENDTC (Start/End Date Time of Adverse Event) AESTDY/AEENDY (Study Day of Start/End of Adverse Event) AEDUR(Duration of Adverse Event): AE. CRF, . , P1DT2H(1 day, 2 hours) 28.1.3.2 CE (Clinical Events) AE CEAE. (), AE, AE. , , ProtocolAE. CE. . , , TIA, ,  CETERM(Reported Term for the Clinical Event): . CRF CEDECOD(Dictionary-Derived Term): . CECAT(Category for Clinical Event):  CEPRESP(Clinical Event Occurrence): CETERM. Y; ,  CEOCCUR(Clinical Event Occurrence): . ,  CESTAT(Completion Status):  CEREASND(Reason Clinical Event Not Collected): . CESTAT=NOT DONE CESEV(Severity/Intensity): . MILD, MODERATE, SEVERE. CEDTC(Date/Time of Event Collection) CESTDTC/CEENDTC(Start/End Date/Time of Clinical Event) CEDY(Study Day of Event Collection): 1. study day, . 2. sponsorRFSTDTC. . CESTRF/CEENRF(Start/End Relative to Reference Period): sponsor/. sponsor, (RFSTDTCRFENDTC). CESTRTPT(Start Relative to Reference Time Point): (CESTTPT) 28.1.3.3 CM (Concomitant and Prior Medications, Interventions) . CM subject, ,    . sponsor. sponsor. . , . CMGRPID(Group ID): subjectdomainrecords CMTRT(Reported Name of Drug, Med, or Therapy, TOPIC): , CRF. CMMODIFY(Modified Reported Name, Synonym Qualifier): CMTRT, CMMODIFY CMDECOD(Standardized Medication Name, Synonym Qualifier): , CMTRTCMMODIFY. generic medication name in WHO Drug. CMCAT(Category for Medication, Grouping Qual):  PRIOR, CONCOMITANT, ANTI-CANCER MEDICAITON, GENERAL CONMED CMSCAT(Subcateory for Medication, Grouping Qual): , CHEMOTHERAPY, HORMONAL THERAPY, ALTERNATIVE THERAPY CMREASND(Reason Medication Not Collected): . CMSTAT=&quot;NOT DONE&quot;CMSTAT CMDOSTXT(Dose Description): . CMDOSU, 200-400, 15-20. CMDOSE, CMDOSTXT CMDOSUDose Units: CMDOSE CMDOSTOT, CMDOSTXT. CMDOSFRM(Dose Form): CMTRT, (TABLET) (LOTION) CMDOSFRQ(Dosing Frequency per Interval): , CMDOSE(). BID(), Q12H(12) CMROUTE(Route of Administration): CMTRT, (ORAL), (INTRAVENNOUS) CMSTDEC/CMENDTC(Start/End Date/Time of Medication CMDUR(Duration of Medication): . CRF,  28.1.3.4 DM (Demographics) RFSTDTC (Subject Reference Start Date/Time): subject. rand pop, subject(Screen failureunassigned). RFENDTC (Subject Reference End Date/TIme): subject, , rand pop, subject(Screen failureunassigned). RFXSTDTC (Date/Time of First Study Treatment): protocol-specified, EXSTDTC. RFXENDTC (Date/Time of Last Study Treatment): protocol-specified, EXSTDTC.(EXENDTC, EXSTDTC). RFICDTC (Date/Time of Informed Consent): , DS domain. RFPENDTC (Date/Time of End of Participation): Subjectfollow-up, Protocol. subject, , , follow-up,   . 28.1.3.5 LB (Laboratory Test Results) hematology, clinical chemistry, urinalysis. domainmicrobiologypharmacokinetic, domain LBTESTCD/LBTEST LBCAT/LBSCAT LBSTNRLO(Reference Range Lower Limit-Std Units):  LBSTNRHI(Upper) LBSTNRC(Reference Range for Char Rslt-Std Units):  (&quot;-1 to +1&quot;)(&quot;NEGATIVE TO TRACE&quot;). LBNRIND(Reference Range Indicator): (LBORNRLO/HI, LBSTNRLO/HI, LBSTNRC) LBSPEC(Specimen Type):   SERUM() PLASMA() URINE() LBSPCCND(Specimen Condition): ,   HEMOLYZED, ICTERIC LBMETHOD(Method of Test or Examination): . EIA(Enzyme Immunoassay), ELECTROPHORESIS, DIPSTICK 28.1.3.6 MH (Medical History) subject. MHgeneral medical history, gynecological history, primary diagnosis.  MHTERM: , MHtopic MHMODIFY, sponsor, . . MHDECOD: sponsorMHTERM, MHDECOD. MHBODSYS: AEsystem organ class MHCAT &amp; MHSCAT: sponsor, CRF. sponsorbody system MHCAT&#39;General Medical History&#39;, &#39;Allergy Medical History&#39;, &#39;Reproductive Medical History&#39;. MHOCCUR. Y N 28.1.3.7 VS (Vital Signs) VSTPTVSELTMISO8601 VSTPT:  VSELTM: , ISO8601 VSPTPREF:  VSRFTDTC: / 28.1.4 SDTM Define.xml XMLExtensible Markup Languagebaidu,zhidaozhuanshu SDTMdefine.xml Table of Contents metadata file Variable-level metadata file Codelist metadata file Value-level metadata file Where clause metadata file Computational method metadata file Comments metadata file External links metadata file Table of Contents Metadata The Table of Contents metadata is called that because it represents the metadata required to produce the Table of Contents section of the define.xml file. The Table of Contents in the define.xml file is just what it sounds like, a list of the domain datasets, what they are for, and where they can be found. define.xml define.xml Variable-Level Metadata SDTM define.xmlItemRefSDTMBase SASSDTM SASSASSAS SDTM Title Title DOMAIN Content VARNUM The order of the variable TYPE text, integer, float, datetime, date, or time, LENGTH Content LABEL Content SIGNIFICANTDIGITS type = float ORIGIN Valid values are: CRF, Derived, Assigned, Protocol, eDT, and Predecessor. CRF may be followed by Page or Pages and the corresponding annotated CRF page numbers (for example, CRF Page 1). If Derived, then a COMPUTATIONMETHODOID should be provided. Predecessor is typically used for ADaM data. 28.1.5 Extract-Transform-Load (ETL) SDTMSASCDISC SDTM SAS SDTM--ETLSAS Title Title make_codelist_formats SDTMSAS DATAPUTSDTM make_empty_dataset SDTMSDTM  make_dtc_date SASISO8601 DATA make_sdtm_dy SDTM * DTCSDTM study day DY DATA make_sort_order  28.1.6 Example Building DM SDTM Datasets SASBase SASSDTM DM (special-purpose DM domain)DY  (supplemental qualifier, findings, events, and interventions) 28.1.6.1 Special-Purpose DM Create empty DM dataset; %make_empty_dataset(metadatafile=SDTM_METADATA.xIs,dataset=DM) Get the first and last dose date of RFSTDTC and RFENDTC; Get demographic data; Merge first and last dose date with demographic Derive majority of the SDTM DM variables; DM; %make_sort_order(metadatafile=SDTM_METADATA.xIs,dataset=DM) **** DERIVE THE MAJORITY OF SDTM DM VARIABLES; options missing = &#39; &#39;; data dm; set EMPTY_DM demog_dose(rename=(race=_race)); studyid = &#39;XYZ123&#39;; domain = &#39;DM&#39;; usubjid = left(uniqueid); subjid = put(subject,3.); rfstdtc = put(firstdose,yymmdd10.); rfendtc = put(lastdose,yymmdd10.); siteid = substr(subjid,1,1) || &quot;00&quot;; brthdtc = put(dob,yymmdd10.); age = floor ((intck(&#39;month&#39;,dob,firstdose) - (day(firstdose) &lt; day(dob))) / 12); if age ne . then ageu = &#39;YEARS&#39;; sex = put(gender,sex_demographic_gender.); race = put(_race,race_demographic_race.); armcd = put(trt,armcd_demographic_trt.); arm = put(trt,arm_demographic_trt.); country = &quot;USA&quot;; run; **** SORT DM ACCORDING TO METADATA AND SAVE PERMANENT DATASET;  %make_sort_order(metadatafile=SDTM_METADATA.xls,dataset=DM) proc sort data=dm(keep = &amp;DMKEEPSTRING) out=target.dm; by &amp;DMSORTSTRING; run; 28.1.6.2 SUPPDM Domains Define SUPPDM for other race; CREATE EMPTY SUPPDM DATASET CALLED EMPTY_SUPPDM; %make_empty_dataset(metadatafile=SDTM_METADATA.xls,dataset=SUPPDM) data suppdm; set EMPTY_SUPPDM dm; keep &amp;SUPPDMKEEPSTRING;  **** OUTPUT OTHER RACE AS A SUPPDM VALUE;  if orace ne &#39;&#39; then do; rd1omain = &#39;DM&#39;; qnam = &#39;RACEOTH&#39;; qlabel = &#39;Race, Other&#39;; qval = left(orace); qorig = &#39;CRF Page 1&#39;; output; end; **** OUTPUT RANDOMIZATION DATE AS SUPPDM VALUE; if randdt ne . then do; rdomain = &#39;DM&#39;; qnam = &#39;RANDDTC&#39;; qlabel = &#39;Randomization Date&#39;; qval = left(put(randdt,yymmdd10.)); qorig = &#39;CRF Page 1&#39;; output; end; run; **** SORT SUPPDM ACCORDING TO METADATA AND SAVE PERMANENT DATASET; %make_sort_order(metadatafile=SDTM_METADATA.xls,dataset=SUPPDM) proc sort data=suppdm out=target.suppdm; by &amp;SUPPDMSORTSTRING; run; 28.1.6.3 Building AE SDTM Datasets CREATE EMPTY DM DATASET CALLED EMPTY_AE; DERIVE THE MAJORITY OF SDTM AE VARIABLES; CREATE SDTM STUDYDAY VARIABLES; CREATE SEQ VARIABLE;\"Sequence Number SORT AE ACCORDING TO METADATA AND SAVE PERMANENT DATASET; **** CREATE EMPTY DM DATASET CALLED EMPTY_AE; %make_empty_dataset(metadatafile=C:\\path\\SDTM_METADATA.xlsx,dataset=AE) **** DERIVE THE MAJORITY OF SDTM AE VARIABLES; options missing = &#39; &#39;; data ae; set EMPTY_AE source.adverse(rename=(aerel=_aerel aesev=_aesev)); studyid = &#39;XYZ123&#39;; domain = &#39;AE&#39;; usubjid = left(uniqueid); aeterm = left(aetext); aedecod = left(prefterm); aebodsys = left(bodysys); aesev = put(_aesev,aesev_adverse_aesev.); aeacn = put(aeaction,acn_adverse_aeaction.); aerel = put(_aerel,aerel_adverse_aerel.); aeser = put(serious,$ny_adverse_serious.); aestdtc = put(aestart,yymmdd10.); aeendtc = put(aeend,yymmdd10.); run; proc sort data=ae; by usubjid; run; **** CREATE SDTM STUDYDAY VARIABLES; data ae; merge ae(in=inae) target.dm(keep=usubjid rfstdtc); by usubjid; if inae; %make_sdtm_dy(date=aestdtc); %make_sdtm_dy(date=aeendtc); run; **** CREATE SEQ VARIABLE; proc sort data=ae; by studyid usubjid aedecod aestdtc aeendtc; run; data ae; retain &amp;AEKEEPSTRING; set ae(drop=aeseq); by studyid usubjid aedecod aestdtc aeendtc; if not (first.aeendtc and last.aeendtc) then put &quot;WARN&quot; &quot;ING: key variables do not define an unique record. &quot; usubjid=; retain aeseq; if first.usubjid then aeseq = 1; else aeseq = aeseq + 1; label aeseq = &quot;Sequence Number&quot;; run; **** SORT AE ACCORDING TO METADATA AND SAVE PERMANENT DATASET; %make_sort_order(metadatafile=C:\\path\\SDTM_METADATA.xlsx,dataset=AE) proc sort data=ae(keep = &amp;AEKEEPSTRING) out=target.ae; by &amp;AESORTSTRING; run; 28.2 SDTM SAS Macro 28.2.1 make_define make_defineSDTMADaMdefine.xmlExceldefine.xml *---------------------------------------------------------------*; * %make_define creates the define.xml file for the SDTM and ADaM. * It creates define.xml based on the contents of a set of metadata * tabs found in an Excel spreadsheet. * * PARAMETERS: * path = System path to where the SDTM or ADaM metadata * file exists as well as where the define.xml * file will be stored. * metadata = The name of the metadata spreadsheet. * * It requires that the following tabs exist in the metadata file: * DEFINE_HEADER_METADATA = define file header metadata * TOC_METADATA = &quot;table of contents&quot; dataset metadata * VARIABLE_METADATA = variable/column level metadata * VALUELEVEL_METADATA = value/parameter level metadata * COMPUTATIONAL_MKETHOD = computational methods * CODELISTS = controlled terminology metadata * ANALYSIS_RESULTS = ADaM analysis metadata. [Only for ADaM define] * EXTERNAL_LINKS = ADaM results file pointers. [Only for ADaM define] *---------------------------------------------------------------*; %macro make_define(path=,metadata=); **** GET DEFINE FILE HEADER INFORMATION METADATA; proc import out = define_header datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet=&quot;DEFINE_HEADER_METADATA&quot;; run; **** DETERMINE IF THIS IS A SDTM DEFINE FILE OR AN ADAM DEFINE FILE **** AND SET THE STANDARD MACRO VARIABLE FOR THE REST OF THE PROGRAM; data _null_; set define_header; if upcase(standard) = &#39;ADAM&#39; then call symput(&#39;standard&#39;,&#39;ADAM&#39;); else if upcase(standard) = &#39;SDTM&#39; then call symput(&#39;standard&#39;,&#39;SDTM&#39;); else put &quot;ERR&quot; &quot;OR: CDISC standard undefined in define_header_metadata&quot;; run; **** GET &quot;TABLE OF CONTENTS&quot; LEVEL DATASET METADATA; proc import out = toc_metadata datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;TOC_METADATA&quot; ; run; **** GET THE VARIABLE METADATA; proc import out = VARIABLE_METADATA datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;VARIABLE_METADATA&quot;; run; **** GET THE CODELIST METADATA; proc import out = codelists datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;CODELISTS&quot; ; run; **** GET THE COMPUTATIONAL METHOD METADATA; proc import out = compmethod datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;COMPUTATION_METHOD&quot; ; run; **** GET THE VALUE LEVEL METADATA; proc import out = valuelevel datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;VALUELEVEL_METADATA&quot; ; run; %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then %do; **** GET THE ANALYSIS RESULTS METADATA; proc import out = analysisresults datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;ANALYSIS_RESULTS&quot; ; run; **** GET THE ANALYSIS RESULTS METADATA; proc import out = externallinks datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;EXTERNAL_LINKS&quot; ; run; %end; **** USE HTMLENCODE ON SOURCE TEXT THAT NEEDS ENCODING FOR PROPER BROWSER REPRESENTATIION; %if &amp;standard=ADAM %then %do; data toc_metadata; length documentation $ 800; set toc_metadata; documentation = htmlencode(documentation); ** convert single quotes to double quotes; documentation = tranwrd(documentation, &quot;&#39;&quot;, &#39;&quot;&#39;); ** convert double quotes to html quote; documentation = tranwrd(trim(documentation), &#39;&quot;&#39;, &#39;&amp;quot;&#39;); format documentation $800.; run; %end; data variable_metadata; length comment $ 2000; set variable_metadata; format comment; informat comment; origin = htmlencode(origin); label = htmlencode(label); comment = htmlencode(comment); **** FOR ADAM, JOIN ORIGIN/&quot;SOURCE&quot; AND COMMENT **** TO FORM &quot;SOURCE/DERIVATION&quot; METADATA; if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin ne &#39;&#39; and comment ne &#39;&#39; then comment = &quot;SOURCE: &quot; || left(trim(origin)) || &quot; DERIVATION: &quot; || left(trim(comment)); else if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin ne &#39;&#39; and comment = &#39;&#39; then comment = &quot;SOURCE: &quot; || left(trim(origin)); if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin = &#39;&#39; and comment ne &#39;&#39; then comment = &quot;DERIVATION: &quot; || left(trim(comment)); run; data codelists; set codelists; codedvalue = htmlencode(codedvalue); translated = htmlencode(translated); run; data compmethod; set compmethod; computationmethod = htmlencode(computationmethod); run; data valuelevel; length comment $ 2000; set valuelevel; format comment; informat comment; origin = htmlencode(origin); label = htmlencode(label); comment = htmlencode(comment); **** FOR ADAM, JOIN ORIGIN/&quot;SOURCE&quot; AND COMMENT **** TO FORM &quot;SOURCE/DERIVATION&quot; METADATA; if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin ne &#39;&#39; and comment ne &#39;&#39; then comment = &quot;SOURCE: &quot; || left(trim(origin)) || &quot; DERIVATION: &quot; || left(trim(comment)); else if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin ne &#39;&#39; and comment = &#39;&#39; then comment = &quot;SOURCE: &quot; || left(trim(origin)); if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin = &#39;&#39; and comment ne &#39;&#39; then comment = &quot;DERIVATION: &quot; || left(trim(comment)); run; %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then %do; data analysisresults; length programmingcode $800. docleafid $40.; set analysisresults; where displayid ne &#39;&#39;; arrow + 1; selectioncriteria = htmlencode(selectioncriteria); paramlist = htmlencode(paramlist); reason = htmlencode(reason); documentation = htmlencode(documentation); if index(documentation, &#39;[r]&#39;)&gt;0 then docleafid = substr(documentation, index(documentation,&#39;[r]&#39;)+3, index(documentation,&#39;[\\r]&#39;)-index(documentation,&#39;[r]&#39;)-3); else docleafid = &#39;.&#39;; programmingcode = htmlencode(programmingcode); ** convert single quotes to double quotes; programmingcode = tranwrd(programmingcode, &quot;&#39;&quot;, &#39;&quot;&#39;); ** convert double quotes to html quote; programmingcode = tranwrd(programmingcode, &#39;&quot;&#39;, &#39;&amp;quot;&#39;); format programmingcode $800.; run; ** ENSURE UNIQUENESS ON DISPLAYID AND RESULTID AND CREATE A COMBO ID; data analysisresults; set analysisresults; by displayid notsorted; drop resultnum; retain resultnum; if first.displayid then resultnum = 0; resultnum + 1; if not(first.displayid and last.displayid) then arid = trim(displayid) || &quot;.R.&quot; || put(resultnum,z2.); else arid = displayid; run; ** IF DOCLEAFID IS NON-MISSING, MERGE IN THE TITLE FROM EXTERNAL_LINKS; proc sort data = analysisresults; by docleafid; run; proc sort data = externallinks (keep = leafid title rename=(leafid=docleafid title=doctitle)) out = doc_links; by docleafid; run; data analysisresults; merge analysisresults (in = inar) doc_links (in = indoc_links); by docleafid; if inar; ** if the leaf ID exists, then the title of the leaf ID will be printed and can be removed from DOCUMENTIATION; if indoc_links then documentation = tranwrd(documentation, &#39;[r]&#39; || trim(docleafid) || &#39;[\\r]&#39;, &quot; &quot;); run; proc sort data = analysisresults; by arrow; run; %end; **** CREATE DEFINE FILE HEADER SECTION; filename dheader &quot;&amp;path\\define_header.txt&quot;; data define_header; set define_header; file dheader notitles; creationdate = compress(put(datetime(), IS8601DT.)); put @1 &#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;&#39; / @1 &#39;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;&#39; stylesheet +(-1) &#39;&quot;?&gt;&#39; / @1 &#39;&lt;!-- ******************************************************************************* --&gt;&#39; / @1 &#39;&lt;!-- File: define.xml --&gt;&#39; / @1 &quot;&lt;!-- Date: &amp;sysdate9. --&gt;&quot; / @1 &#39;&lt;!-- Description: Define.xml file for &#39; studyname +(-1) &#39; --&gt;&#39; / @1 &#39;&lt;!-- ******************************************************************************* --&gt;&#39; / @1 &#39;&lt;ODM&#39; / @3 &#39;xmlns=&quot;http://www.cdisc.org/ns/odm/v1.2&quot;&#39; / @3 &#39;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#39; / @3 &#39;xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&#39; / @3 &#39;xmlns:def=&quot;http://www.cdisc.org/ns/def/v1.0&quot;&#39; / %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then @3 &#39;xmlns:adamref=&quot;http://www.cdisc.org/ns/ADaMRes/DRAFT&quot;&#39; / ; @3 &#39;xsi:schemaLocation=&quot;&#39; schemalocation +(-1) &#39;&quot;&#39; / @3 &#39;FileOID=&quot;&#39; fileoid +(-1) &#39;&quot;&#39; / @3 &#39;ODMVersion=&quot;1.2&quot;&#39; / @3 &#39;FileType=&quot;Snapshot&quot;&#39; / @3 &#39;CreationDateTime=&quot;&#39; creationdate +(-1) &#39;&quot;&gt;&#39; / @1 &#39;&lt;Study OID=&quot;&#39; studyoid +(-1) &#39;&quot;&gt;&#39; / @3 &#39;&lt;GlobalVariables&gt;&#39; / @5 &#39;&lt;StudyName&gt;&#39; studyname +(-1) &#39;&lt;/StudyName&gt;&#39; / @5 &#39;&lt;StudyDescription&gt;&#39; studydescription +(-1) &#39;&lt;/StudyDescription&gt;&#39; / @5 &#39;&lt;ProtocolName&gt;&#39; protocolname +(-1) &#39;&lt;/ProtocolName&gt;&#39; / @3 &#39;&lt;/GlobalVariables&gt;&#39; / @3 &#39;&lt;MetaDataVersion OID=&quot;CDISC.&#39; standard +(-1) &#39;.&#39; version +(-1) &#39;&quot;&#39; / @5 &#39;Name=&quot;&#39; studyname +(-1) &#39;,Data Definitions&quot;&#39; / @5 &#39;Description=&quot;&#39; studyname +(-1) &#39;,Data Definitions&quot;&#39; / @5 &#39;def:DefineVersion=&quot;1.0.0&quot;&#39; / @5 &#39;def:StandardName=&quot;CDISC &#39; standard +(-1) &#39;&quot;&#39; / @5 &#39;def:StandardVersion=&quot;&#39; version +(-1) &#39;&quot;&gt;&#39; / %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then %do; @5 &#39;&lt;def:SupplementalDoc&gt;&#39; / @7 &#39;&lt;def:DocumentRef leafID=&quot;Suppdoc&quot;/&gt;&#39; / @5 &#39;&lt;/def:SupplementalDoc&gt;&#39; / @5 &#39;&lt;def:leaf ID=&quot;Suppdoc&quot; xlink:href=&quot;dataguide.pdf&quot;&gt;&#39; / @7 &#39;&lt;def:title&gt;Data Guide&lt;/def:title&gt;&#39; / %end; %else %if &quot;&amp;standard&quot; = &quot;SDTM&quot; %then %do; @5 &#39;&lt;def:AnnotatedCRF&gt;&#39; / @7 &#39;&lt;def:DocumentRef leafID=&quot;blankcrf&quot;/&gt;&#39; / @5 &#39;&lt;/def:AnnotatedCRF&gt;&#39; / @5 &#39;&lt;def:leaf ID=&quot;blankcrf&quot; xlink:href=&quot;blankcrf.pdf&quot;&gt;&#39; / @7 &#39;&lt;def:title&gt;Annotated Case Report Form&lt;/def:title&gt;&#39; / %end; @5 &#39;&lt;/def:leaf&gt;&#39;; run; **** ADD OTHER ADAM EXTERNAL LINKS; %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then %do; filename leaves &quot;&amp;path\\leaves.txt&quot;; data _null_; set externallinks; file leaves notitles; put @5 &#39;&lt;def:leaf ID=&quot;&#39; leafid +(-1) &#39;&quot;&#39; / @7 &#39;xlink:href=&quot;&#39; leafrelpath +(-1) &#39;&quot;&gt;&#39; / @7 &#39;&lt;def:title&gt;&#39; title &#39;&lt;/def:title&gt;&#39; / @5 &#39;&lt;/def:leaf&gt;&#39; ; run; %end; **** ADD ITEMOID TO VARIABLE METADATA; data variable_metadata; set variable_metadata(rename=(domain = oid)); length itemoid $ 40; if variable in (&quot;STUDYID&quot;,&quot;DOMAIN&quot;,&quot;USUBJID&quot;,&quot;SUBJID&quot;) then itemoid = variable; else itemoid = compress(oid || &quot;.&quot; || variable); run; **** ADD ITEMOID TO VALUE LEVEL METADATA; data valuelevel; set valuelevel; length itemoid $ 200; itemoid = compress(valuelistoid || &quot;.&quot; || valuename); run; **** CREATE COMPUTATION METHOD SECTION; filename comp &quot;&amp;path\\compmethod.txt&quot;; data compmethods; set compmethod; file comp notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ******************************************* --&gt;&quot; / @5 &quot;&lt;!-- COMPUTATIONAL METHOD INFORMATION *** --&gt;&quot; / @5 &quot;&lt;!-- ******************************************* --&gt;&quot;; put @5 &#39;&lt;def:ComputationMethod OID=&quot;&#39; computationmethodoid +(-1) &#39;&quot;&gt;&#39; computationmethod +(-1) &#39;&lt;/def:ComputationMethod&gt;&#39;; run; **** CREATE VALUE LEVEL LIST DEFINITION SECTION; proc sort data=valuelevel; where valuelistoid ne &#39;&#39;; by valuelistoid; run; filename vallist &quot;&amp;path\\valuelist.txt&quot;; data valuelevel; set valuelevel; by valuelistoid; file vallist notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ******************************************* --&gt;&quot; / @5 &quot;&lt;!-- VALUE LEVEL LIST DEFINITION INFORMATION ** --&gt;&quot; / @5 &quot;&lt;!-- ******************************************* --&gt;&quot;; if first.valuelistoid then put @5 &#39;&lt;def:ValueListDef OID=&quot;&#39; valuelistoid +(-1) &#39;&quot;&gt;&#39;; put @7 &#39;&lt;ItemRef ItemOID=&quot;&#39; itemoid /*valuename*/ +(-1) &#39;&quot;&#39; / @9 &#39;Mandatory=&quot;&#39; mandatory +(-1) &#39;&quot;/&gt;&#39;; if last.valuelistoid then put @5 &#39;&lt;/def:ValueListDef&gt;&#39;; run; **** CREATE &quot;ITEMGROUPDEF&quot; SECTION; proc sort data=VARIABLE_METADATA; where oid ne &#39;&#39;; by oid varnum; run; proc sort data=toc_metadata; where oid ne &#39;&#39;; by oid; run; filename igdef &quot;&amp;path\\itemgroupdef.txt&quot;; data itemgroupdef; length label $ 40; merge toc_metadata VARIABLE_METADATA(drop=label); by oid; file igdef notitles; if first.oid then do; put @5 &quot;&lt;!-- ******************************************* --&gt;&quot; / @5 &quot;&lt;!-- &quot; oid @25 &quot;ItemGroupDef INFORMATION *** --&gt;&quot; / @5 &quot;&lt;!-- ******************************************* --&gt;&quot; / @5 &#39;&lt;ItemGroupDef OID=&quot;&#39; oid +(-1) &#39;&quot;&#39; / @7 &#39;Name=&quot;&#39; name +(-1) &#39;&quot;&#39; / @7 &#39;Repeating=&quot;&#39; repeating +(-1) &#39;&quot;&#39; / @7 &#39;Purpose=&quot;&#39; purpose +(-1) &#39;&quot;&#39; / @7 &#39;IsReferenceData=&quot;&#39; isreferencedata +(-1) &#39;&quot;&#39; / @7 &#39;def:Label=&quot;&#39; label +(-1) &#39;&quot;&#39; / @7 &#39;def:Structure=&quot;&#39; structure +(-1) &#39;&quot;&#39; / @7 &#39;def:DomainKeys=&quot;&#39; domainkeys +(-1) &#39;&quot;&#39; / @7 &#39;def:Class=&quot;&#39; class +(-1) &#39;&quot;&#39; ; %if &amp;standard=ADAM %then put @7 &#39;def:ArchiveLocationID=&quot;Location.&#39; archivelocationid +(-1) &#39;&quot;&#39; / @7 &#39;Comment=&quot;&#39; documentation +(-1) &#39;&quot;&gt;&#39; ; %else put @7 &#39;def:ArchiveLocationID=&quot;Location.&#39; archivelocationid +(-1) &#39;&quot;&gt;&#39;; ; end; put @7 &#39;&lt;ItemRef ItemOID=&quot;&#39; itemoid +(-1) &#39;&quot;&#39; / @9 &#39;OrderNumber=&quot;&#39; varnum +(-1) &#39;&quot;&#39; / @9 &#39;Mandatory=&quot;&#39; mandatory +(-1) @; if role ne &#39;&#39; and &quot;&amp;standard&quot; = &quot;SDTM&quot; then put &#39;&quot;&#39; / @9 &#39;Role=&quot;&#39; role +(-1) &#39;&quot;&#39; / @9 &#39;RoleCodeListOID=&quot;CodeList.&#39; rolecodelist +(-1) &#39;&quot;/&gt;&#39;; else put &#39;&quot;/&gt;&#39;; if last.oid then put @7 &quot;&lt;!-- **************************************************** --&gt;&quot; / @7 &quot;&lt;!-- def:leaf details for hypertext linking the dataset --&gt;&quot; / @7 &quot;&lt;!-- **************************************************** --&gt;&quot; / @7 &#39;&lt;def:leaf ID=&quot;Location.&#39; oid +(-1) &#39;&quot; xlink:href=&quot;&#39; archivelocationid +(-1) &#39;.xpt&quot;&gt;&#39; / @9 &#39;&lt;def:title&gt;&#39; archivelocationid +(-1) &#39;.xpt &lt;/def:title&gt;&#39; / @7 &#39;&lt;/def:leaf&gt;&#39; / @5 &#39;&lt;/ItemGroupDef&gt;&#39;; run; **** CREATE &quot;ITEMDEF&quot; SECTION; filename idef &quot;&amp;path\\itemdef.txt&quot;; data itemdef; set VARIABLE_METADATA end=eof; by oid; file idef notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; / @5 &quot;&lt;!-- The details of each variable is here for all domains --&gt;&quot; / @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; ; put @5 &#39;&lt;ItemDef OID=&quot;&#39; itemoid +(-1) &#39;&quot;&#39; / @7 &#39;Name=&quot;&#39; variable +(-1) &#39;&quot;&#39; / @7 &#39;DataType=&quot;&#39; type +(-1) &#39;&quot;&#39; / @7 &#39;Length=&quot;&#39; length +(-1) &#39;&quot;&#39;; if significantdigits ne &#39;&#39; then put @7 &#39;SignificantDigitis=&quot;&#39; significantdigits +(-1) &#39;&quot;&#39;; if displayformat ne &#39;&#39; then put @7 &#39;def:DisplayFormat=&quot;&#39; displayformat +(-1) &#39;&quot;&#39;; if computationmethodoid ne &#39;&#39; then put @7 &#39;def:ComputationMethodOID=&quot;&#39; computationmethodoid +(-1) &#39;&quot;&#39;; put %if &quot;&amp;standard&quot; = &quot;SDTM&quot; %then @7 &#39;Origin=&quot;&#39; origin +(-1) &#39;&quot;&#39; / ; @7 &#39;Comment=&quot;&#39; comment +(-1) &#39;&quot;&#39; / @7 &#39;def:Label=&quot;&#39; label +(-1) &#39;&quot;&gt;&#39;; if codelistname ne &#39;&#39; then put @7 &#39;&lt;CodeListRef CodeListOID=&quot;CodeList.&#39; codelistname +(-1) &#39;&quot;/&gt;&#39;; if valuelistoid ne &#39;&#39; then put @7 &#39;&lt;def:ValueListRef ValueListOID=&quot;&#39; valuelistoid +(-1) &#39;&quot;/&gt;&#39;; put @5 &#39;&lt;/ItemDef&gt;&#39;; run; **** ADD ITEMDEFS FOR VALUE LEVEL ITEMS TO &quot;ITEMDEF&quot; SECTION; filename idefvl &quot;&amp;path\\itemdef_value.txt&quot;; data itemdefvalue; set valuelevel end=eof; by valuelistoid; file idefvl notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; / @5 &quot;&lt;!-- The details of value level items are here --&gt;&quot; / @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; ; put @5 &#39;&lt;ItemDef OID=&quot;&#39; itemoid /*valuename*/ +(-1) &#39;&quot;&#39; / @7 &#39;Name=&quot;&#39; valuename +(-1) &#39;&quot;&#39; / @7 &#39;DataType=&quot;&#39; type +(-1) &#39;&quot;&#39; / @7 &#39;Length=&quot;&#39; length +(-1) &#39;&quot;&#39;; if significantdigits ne &#39;&#39; then put @7 &#39;SignificantDigitis=&quot;&#39; significantdigits +(-1) &#39;&quot;&#39;; if displayformat ne &#39;&#39; then put @7 &#39;def:DisplayFormat=&quot;&#39; displayformat +(-1) &#39;&quot;&#39;; if computationmethodoid ne &#39;&#39; then put @7 &#39;def:ComputationMethodOID=&quot;&#39; computationmethodoid +(-1) &#39;&quot;&#39;; put %if &quot;&amp;standard&quot; = &quot;SDTM&quot; %then @7 &#39;Origin=&quot;&#39; origin +(-1) &#39;&quot;&#39; / ; @7 &#39;Comment=&quot;&#39; comment +(-1) &#39;&quot;&#39; / @7 &#39;def:Label=&quot;&#39; label +(-1) &#39;&quot;&gt;&#39;; if codelistname ne &#39;&#39; then put @7 &#39;&lt;CodeListRef CodeListOID=&quot;CodeList.&#39; codelistname +(-1) &#39;&quot;/&gt;&#39;; put @5 &#39;&lt;/ItemDef&gt;&#39;; run; **** ADD ANALYSIS RESULTS METADATA SECTION FOR ADAM; %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then %do; filename ar &quot;&amp;path\\analysisresults.txt&quot;; data _null_; set analysisresults; ** note that it is required that identical display IDs be adjacent to ** each other in the metadata spreadsheet; by displayid notsorted; file ar notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; / @5 &quot;&lt;!-- Analysis Results MetaData are Presented Below --&gt;&quot; / @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; ; if first.displayid then put @5 &#39;&lt;adamref:AnalysisResultDisplays&gt;&#39; / @7 &#39;&lt;adamref:ResultDisplay DisplayIdentifier=&quot;&#39; displayid +(-1) &#39;&quot; OID=&quot;&#39; displayid +(-1) &#39;&quot; DisplayLabel=&quot;&#39; displayname +(-1) &#39;&quot; leafID=&quot;&#39; displayid +(-1) &#39;&quot;&gt;&#39; ; put @9 &#39;&lt;adamref:AnalysisResults &#39; / @9 &#39;OID=&quot;&#39; arid +(-1) &#39;&quot;&#39; / @9 &#39;ResultIdentifier=&quot;&#39; resultid +(-1) &#39;&quot;&#39; / @9 &#39;Reason=&quot;&#39; reason +(-1) &#39;&quot;&gt;&#39; / @9 &#39;&lt;!-- List the parameters and parameter codes --&gt;&#39; / @9 &#39;&lt;adamref:ParameterList&gt;&#39; ; ** loop through PARAMCD/PARAM sets; set = 1; do while(scan(paramlist,set,&#39;|&#39;) ne &#39;&#39;); paramset = scan(paramlist,set,&#39;|&#39;); paramcd = scan(paramset,1,&#39;/\\&#39;); param = trim(scan(paramset,2,&#39;/\\&#39;)); put @11 &#39;&lt;adamref:Parameter ParamCD=&quot;&#39; paramcd +(-1) &#39;&quot; Param=&quot;&#39; param +(-1) &#39;&quot;/&gt;&#39; ; set = set + 1; end; put @9 &#39;&lt;/adamref:ParameterList&gt;&#39;; ** loop through the analysis variables; set = 1; do while(scan(analysisvariables,set,&#39;,&#39;) ne &#39;&#39;); analysisvar = scan(analysisvariables,set,&#39;,&#39;); put @11 &#39;&lt;adamref:AnalysisVariable ItemOID=&quot;&#39; analysisdataset +(-1) &#39;.&#39; analysisvar +(-1) &#39;&quot;/&gt;&#39;; set = set + 1; end; put @9 &#39;&lt;!-- AnalysisDatasets are pairs of dataset references and selection criteria. Dataset references are ItemGroupRefs. The label in the xsl is the def:label for the ItemGroup --&gt;&#39;; put @9 &#39;&lt;adamref:AnalysisDataset&gt;&#39; / @11 &#39;&lt;ItemGroupRef ItemGroupOID=&quot;&#39; analysisdataset +(-1) &#39;&quot; Mandatory=&quot;No&quot;/&gt;&#39; / @11 &#39;&lt;adamref:SelectionCriteria&gt;&#39; / /* just use the row number of the data set as the unique number for the selection criteria */ @13 &#39;&lt;def:ComputationMethod OID=&quot;SC&#39; _n_ z3. &#39;&quot; Name=&quot;Selection Criteria &#39; _n_ z3. &#39;&quot;&gt; [&#39; selectioncriteria &#39; ]&lt;/def:ComputationMethod&gt; &#39;/ @11 &#39;&lt;/adamref:SelectionCriteria&gt; &#39; / @9 &#39;&lt;/adamref:AnalysisDataset&gt; &#39; / @9 &#39;&lt;adamref:Documentation leafID=&quot;&#39; docleafid +(-1) &#39;&quot;&gt;&#39; / @11 &#39;&lt;TranslatedText xml:lang=&quot;en&quot;&gt;&#39; Documentation / @11 &#39;&lt;/TranslatedText&gt;&#39; / @9 &#39;&lt;/adamref:Documentation&gt;&#39; / @9 &#39;&lt;adamref:ProgrammingCode&gt;&#39; / @9 &#39;&lt;def:ComputationMethod OID=&quot;&#39; displayid +(-1) &#39;&quot;&gt;&#39; / @1 ProgrammingCode / @9 &#39;&lt;/def:ComputationMethod&gt;&#39; / @9 &#39;&lt;/adamref:ProgrammingCode&gt;&#39; / @7 &#39;&lt;/adamref:AnalysisResults&gt;&#39; ; if last.displayid then put @5 &#39;&lt;/adamref:ResultDisplay&gt;&#39; / @5 &#39;&lt;/adamref:AnalysisResultDisplays&gt;&#39; ; run; %end; **** CREATE CODELIST SECTION; filename codes &quot;&amp;path\\codelist.txt&quot;; proc sort data=codelists nodupkey; by codelistname codedvalue translated; run; **** MAKE SURE CODELIST IS UNIQUE; data _null_; set codelists; by codelistname codedvalue; if not (first.codedvalue and last.codedvalue) then put &quot;ERR&quot; &quot;OR: multiple versions of the same coded value &quot; codelistname= codedvalue=; run; proc sort data=codelists; by codelistname rank; run; data codelists; set codelists end=eof; by codelistname rank; file codes notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; / @5 &quot;&lt;!-- Codelists are presented below --&gt;&quot; / @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; ; if first.codelistname then put @5 &#39;&lt;CodeList OID=&quot;CodeList.&#39; codelistname +(-1) &#39;&quot;&#39; / @7 &#39;Name=&quot;&#39; codelistname +(-1) &#39;&quot;&#39; / @7 &#39;DataType=&quot;&#39; type +(-1) &#39;&quot;&gt;&#39;; **** output codelists that are not external dictionaries; if codelistdictionary = &#39;&#39; then do; put @7 &#39;&lt;CodeListItem CodedValue=&quot;&#39; codedvalue +(-1) &#39;&quot;&#39; @; if rank ne . then put &#39; def:Rank=&quot;&#39; rank +(-1) &#39;&quot;&gt;&#39;; else put &#39;&gt;&#39;; put @9 &#39;&lt;Decode&gt;&#39; / @11 &#39;&lt;TranslatedText&gt;&#39; translated +(-1) &#39;&lt;/TranslatedText&gt;&#39; / @9 &#39;&lt;/Decode&gt;&#39; / @7 &#39;&lt;/CodeListItem&gt;&#39;; end; **** output codelists that are pointers to external codelists; if codelistdictionary ne &#39;&#39; then put @7 &#39;&lt;ExternalCodeList Dictionary=&quot;&#39; codelistdictionary +(-1) &#39;&quot; Version=&quot;&#39; codelistversion +(-1) &#39;&quot;/&gt;&#39;; if last.codelistname then put @5 &#39;&lt;/CodeList&gt;&#39;; if eof then put @3 &#39;&lt;/MetaDataVersion&gt;&#39; / @1 &#39;&lt;/Study&gt;&#39; / @1 &#39;&lt;/ODM&gt;&#39;; run; ** create the .BAT file that will put all of the files together to create the define; filename dotbat &quot;make_define.bat&quot;; data _null_; file dotbat notitles; drive = substr(&quot;&amp;path&quot;,1,2); put @1 drive; put @1 &quot;cd &amp;path&quot;; if &quot;&amp;standard&quot; = &quot;ADAM&quot; then put @1 &quot;type define_header.txt leaves.txt compmethod.txt valuelist.txt itemgroupdef.txt itemdef.txt itemdef_value.txt analysisresults.txt codelist.txt &gt; define.xml&quot;; else if &quot;&amp;standard&quot; = &quot;SDTM&quot; then put @1 &quot;type define_header.txt leaves.txt compmethod.txt valuelist.txt itemgroupdef.txt itemdef.txt itemdef_value.txt codelist.txt &gt; define.xml&quot;; put @1 &quot;exit&quot;; run; x &quot;make_define&quot;; %mend make_define; 28.2.2 %make_codelist_formats *---------------------------------------------------------------*; * make_codelist_formats.sas creates a permanent SAS format library * stored to the libref LIBRARY from the codelist metadata file * CODELISTS.xlsx. The permanent format library that is created * contains formats that are named like this: * CODELISTNAME_SOURCEDATASET_SOURCEVARIABLE * where CODELISTNAME is the name of the SDTM codelist, * SOURCEDATASET is the name of the source SAS dataset and * SOURCEVARIABLE is the name of the source SAS variable. *---------------------------------------------------------------*; proc import datafile=&quot;C:\\path\\SDTM_METADATA.xlsx&quot; out=formatdata dbms=excelcs replace; sheet=&quot;CODELISTS&quot;; run; ** make a proc format control dataset out of the SDTM metadata; data source.formatdata; set formatdata(drop=type); where sourcedataset ne &quot;&quot; and sourcevalue ne &quot;&quot;; keep fmtname start end label type; length fmtname $ 32 start end $ 16 label $ 200 type $ 1; fmtname = compress(codelistname || &quot;_&quot; || sourcedataset || &quot;_&quot; || sourcevariable); start = left(sourcevalue); end = left(sourcevalue); label = left(codedvalue); if upcase(sourcetype) = &quot;NUMBER&quot; then type = &quot;N&quot;; else if upcase(sourcetype) = &quot;CHARACTER&quot; then type = &quot;C&quot;; run; ** create a SAS format library to be used in SDTM conversions; proc format library=library cntlin=source.formatdata fmtlib; run; 28.2.3 %make_empty_dataset *---------------------------------------------------------------*; * make_empty_dataset.sas creates a zero record dataset based on a * dataset metadata spreadsheet. The dataset created is called * EMPTY_** where &quot;**&quot; is the name of the dataset. This macro also * creates a global macro variable called **KEEPSTRING that holds * the dataset variables desired and listed in the order they * should appear. [The variable order is dictated by VARNUM in the * metadata spreadsheet.] * * MACRO PARAMETERS: * metadatafile = the MS Excel file containing the dataset metadata * dataset = the dataset or domain name you want to extract *---------------------------------------------------------------*; %macro make_empty_dataset(metadatafile=,dataset=); proc import datafile=&quot;&amp;metadatafile&quot; out=_temp dbms=excelcs replace; sheet=&quot;VARIABLE_METADATA&quot;; run; ** sort the dataset by expected specified variable order; proc sort data=_temp; where domain = &quot;&amp;dataset&quot;; by varnum; run; ** create keepstring macro variable and load metadata ** information into macro variables; %global &amp;dataset.KEEPSTRING; data _null_; set _temp nobs=nobs end=eof; if _n_=1 then call symput(&quot;vars&quot;, compress(put(nobs,3.))); call symputx(&#39;var&#39; || compress(put(_n_, 3.)), variable); call symputx(&#39;label&#39; || compress(put(_n_, 3.)), label); call symputx(&#39;length&#39; || compress(put(_n_, 3.)), put(length, 3.)); ** valid ODM types include TEXT, INTEGER, FLOAT, DATETIME, ** DATE, TIME and map to SAS numeric or character; if upcase(type) in (&quot;INTEGER&quot;, &quot;FLOAT&quot;) then call symputx(&#39;type&#39; || compress(put(_n_, 3.)), &quot;&quot;); else if upcase(type) in (&quot;TEXT&quot;, &quot;DATE&quot;, &quot;DATETIME&quot;, &quot;DATE&quot;, &quot;TIME&quot;) then call symputx(&#39;type&#39; || compress(put(_n_, 3.)), &quot;$&quot;); else put &quot;ERR&quot; &quot;OR: not using a valid ODM type. &quot; type=; ** create **KEEPSTRING macro variable; length keepstring $ 32767; retain keepstring; keepstring = compress(keepstring) || &quot;|&quot; || left(variable); if eof then call symputx(upcase(compress(&quot;&amp;dataset&quot; || &#39;KEEPSTRING&#39;)), left(trim(translate(keepstring,&quot; &quot;,&quot;|&quot;)))); run; ** create a 0-observation template data set used for assigning ** variable attributes to the actual data sets; data EMPTY_&amp;dataset; %do i=1 %to &amp;vars; attrib &amp;&amp;var&amp;i label=&quot;&amp;&amp;label&amp;i&quot; length=&amp;&amp;type&amp;i.&amp;&amp;length&amp;i... ; %if &amp;&amp;type&amp;i=$ %then retain &amp;&amp;var&amp;i &#39;&#39;; %else retain &amp;&amp;var&amp;i .; ; %end; if 0; run; %mend make_empty_dataset; *** Suppose you submit the macro like this for the DM domain; %make_empty_dataset(metadatafile=SDTM_METADATA.xls,dataset=DM) proc contents data=work.empty_dm; run; 28.2.4 %make_dtc_date *---------------------------------------------------------------*; * make_dtc_date.sas is a SAS macro that creates a SDTM --DTC date * within a SAS datastep when provided the pieces of the date in * separate SAS variables. * * NOTE: This macro must have SAS OPTIONS MISSING = &#39; &#39; set before * it is called to handle missing date parts properly. * * MACRO PARAMETERsS: * dtcdate = SDTM --DTC date variable desired * year = year variable * month = month variable * day = day variable * hour = hour variable * minute = minute variable * second = second variable *---------------------------------------------------------------*; %macro make_dtc_date(dtcdate=, year=., month=., day=., hour=., minute=., second=.); ** in a series of if-then-else statements, determine where the ** smallest unit of date and time is present and then construct a DTC ** date based on the non-missing date variables.; if (&amp;second ne .) then &amp;dtcdate = put(&amp;year,z4.) || &quot;-&quot; || put(&amp;month,z2.) || &quot;-&quot; || put(&amp;day,z2.) || &quot;T&quot; || put(&amp;hour,z2.) || &quot;:&quot; || put(&amp;minute,z2.) || &quot;:&quot; || put(&amp;second,z2.); else if (&amp;minute ne .) then &amp;dtcdate = put(&amp;year,z4.) || &quot;-&quot; || put(&amp;month,z2.) || &quot;-&quot; || put(&amp;day,z2.) || &quot;T&quot; || put(&amp;hour,z2.) || &quot;:&quot; || put(&amp;minute,z2.); else if (&amp;hour ne .) then &amp;dtcdate = put(&amp;year,z4.) || &quot;-&quot; || put(&amp;month,z2.) || &quot;-&quot; || put(&amp;day,z2.) || &quot;T&quot; || put(&amp;hour,z2.); else if (&amp;day ne .) then &amp;dtcdate = put(&amp;year,z4.) || &quot;-&quot; || put(&amp;month,z2.) || &quot;-&quot; || put(&amp;day,z2.); else if (&amp;month ne .) then &amp;dtcdate = put(&amp;year,z4.) || &quot;-&quot; || put(&amp;month,z2.); else if (&amp;year ne .) then &amp;dtcdate = put(&amp;year,z4.); else if (&amp;year = .) then &amp;dtcdate = &quot;&quot;; ** remove duplicate blanks and replace space with a dash; if &amp;dtcdate ne &quot;&quot; then &amp;dtcdate = translate(trim(compbl(&amp;dtcdate)),&#39;-&#39;,&#39; &#39;); %mend make_dtc_date; *** sample call of this SAS macro for the EX domain: data ex; %make_dtc_date(dtcdate=exstdtc, year=startyy, month=startmm, day=startdd) %make_dtc_date(dtcdate=exendtc, year=endyy, month=endmm, day=enddd, hour=endhh, minute=endmi, second=endss) run; *** create the variable EXSTDTC in the resulting EX dataset in the YYYY-MM-DD format; *** EXENDTC in the YYYY-MM-DDTHH:MM:SS format; 28.2.5 %make_sdtm_dy *---------------------------------------------------------------*; * make_sdtm_dy.sas is a SAS macro that takes two SDTM --DTC dates * and calculates a SDTM study day (--DY) variable. It must be used * in a datastep that has both the REFDATE and DATE variables * specified in the macro parameters below. * MACRO PARAMETERS: * refdate = --DTC baseline date to calculate the --DY from. * This should be DM.RFSTDTC for SDTM --DY variables. * date = --DTC date to calculate the --DY to. The variable * associated with the --DY variable. *---------------------------------------------------------------*; %macro make_sdtm_dy(refdate=RFSTDTC,date=); if length(&amp;date) &gt;= 10 and length(&amp;refdate) &gt;= 10 then do; if input(substr(%substr(&quot;&amp;date&quot;,2,%length(&amp;date)-3)dtc,1,10),yymmdd10.) &gt;= input(substr(%substr(&quot;&amp;refdate&quot;,2,%length(&amp;refdate)-3)dtc,1,10),yymmdd10.) then %upcase(%substr(&quot;&amp;date&quot;,2,%length(&amp;date)-3))DY = input(substr(%substr(&quot;&amp;date&quot;,2,%length(&amp;date)-3)dtc,1,10),yymmdd10.) - input(substr(%substr(&quot;&amp;refdate&quot;,2,%length(&amp;refdate)-3)dtc,1,10),yymmdd10.) + 1; else %upcase(%substr(&quot;&amp;date&quot;,2,%length(&amp;date)-3))DY = input(substr(%substr(&quot;&amp;date&quot;,2,%length(&amp;date)-3)dtc,1,10),yymmdd10.) - input(substr(%substr(&quot;&amp;refdate&quot;,2,%length(&amp;refdate)-3)dtc,1,10),yymmdd10.); end; %mend make_sdtm_dy; *** A sample call of this SAS macro for the EX domain; data lb; merge lb(in=inlb) target.dm(keep=usubjid rfstdtc); by usubjid; if inlb; %make_sdtm_dy(date=lbdtc) run; 28.2.6 %make_sort_order SORTSTRING *----------------------------------------------------------------*; * make_sort_order.sas creates a global macro variable called * **SORTSTRING where ** is the name of the dataset that contains * the metadata specified sort order for a given dataset. * * MACRO PARAMETERS: * metadatafile = the file containing the dataset metadata * dataset = the dataset or domain name *----------------------------------------------------------------*; %macro make_sort_order(metadatafile=,dataset=); proc import datafile=&quot;&amp;metadatafile&quot; out=_temp dbms=excelcs replace; sheet=&quot;TOC_METADATA&quot;; run; ** create **SORTSTRING macro variable; %global &amp;dataset.SORTSTRING; data _null_; set _temp; where name = &quot;&amp;dataset&quot;; call symputx(compress(&quot;&amp;dataset&quot; || &quot;SORTSTRING&quot;), translate(domainkeys,&quot; &quot;,&quot;,&quot;)); run; %mend make_sort_order; 28.2.7 %Create_STDM_Domains Macro to create an SDTMIG-conform domain dataset Furthermore, the following validation checks are done: Correct length of variables in the specification sheet Variables with length &gt; 200 Discrepancies in variable type between specification sheet and dataset Discrepancies in variables between specification sheet and dataset Macro Variables Description metadatafile Name of specification file (usually imported by init-program) domain Input dataset delete Indicate whether temporary datasets should be deleted (deletion is done if delete is not empty) Content Content Input Domain-dataset with all variables of the SDTM domain and supp-domain (supp-domain variables are only required for consistency checks) SDTMsupp Output Main domain with in SAS7BDAT-format (domain_XX_new) Dataset with results of the validation checks Domain_XX_completeness_chk Domain_XX_length *** Create final domain dataset; %macro create_sdtm_domain (metadatafile, /* Name of specification file (usually imported by init-program) */ domain, /* Input dataset */ delete /* Indicate whether temporary datasets should be deleted (deletion is done if delete is not empty) */ ); *** Extract metadata, relevant for creation of the domain, from the specification sheet  (supp-domain variables are not required here since supp-domains are created by another macro); data _domain_&amp;domain._specs; length Variable_Name $32.; set &amp;metadatafile (where=(strip(upcase(Domain_Prefix)) eq upcase(&quot;&amp;domain&quot;) and SUPP ne &quot;Y&quot;)); order = input(Seq__For_Order, best12.); keep order Variable_Name Variable_Label Type Display_Format; run; *** Extract metadata, relevant for consistency checks, from the specification sheet  (consistency checks are also done for supp-domain variables); data _domain_&amp;domain._specs_for_chk; length Variable_Name $32.; set &amp;metadatafile (where=(Domain_Prefix eq &quot;&amp;domain&quot;)); order = input(Seq__For_Order, best12.); keep order Variable_Name Variable_Label Type Display_Format; run; *** Sort metadata for consistency checks; proc sort data=_domain_&amp;domain._specs_for_chk; by Variable_Name; run; *** Check whether all SDTM variables defined in the specification sheet are in the SAS dataset with domain data (and vice versa); *SDTMSAS; *** In case of SDTM domain DM it can be only checked whether all SDTM variables defined in the specification sheet are in the SAS dataset with domain data (but not vice versa) (DM variables have no domain abbreviation); %if &amp;domain eq DM %then %do; *** Get a dataset with a column which lists all variable names in the SAS dataset with domain data; proc contents data=domain_&amp;domain out=_domain_&amp;domain._all_var noprint; run; *** Sort for merge; proc sort data=_domain_&amp;domain._all_var(keep=NAME); by NAME; run; data _domain_&amp;domain._all_var; set _domain_&amp;domain._all_var; run; *** Check for completeness (SAS dataset with domain data only), create a warning (if applicable) and output the entry in a dataset for tracking; data domain_&amp;domain._completeness_chk; merge _domain_&amp;domain._specs_for_chk (in=inSPECS rename=(Type=Type_Specs) where=(Variable_Name not in (&quot;STUDYID&quot; &quot;DOMAIN&quot; &quot;USUBJID&quot; ))) _domain_&amp;domain._all_var (in=inDOMAIN rename=(Name=Variable_Name)); by Variable_Name; if inSPECS and not inDOMAIN then do; put &quot;WARNING: Variable &quot; Variable_Name &quot; is part of the specification but not of the final &amp;domain dataset (user-defined)&quot;; NOT_IN_DOMAIN = &quot;Y&quot;; output; end; run; %end; %if &amp;domain ne DM %then %do; *** Get a dataset with a column which lists all variable names in the SAS dataset with domain data; proc contents data=domain_&amp;domain out=_domain_&amp;domain._all_var noprint; run; *** Keep only entries with variable names starting with the domain abbreviation (entries for variables name for which the domain abbreviation is followed by &quot;_&quot; are deleted); proc sort data=_domain_&amp;domain._all_var(keep=NAME); by NAME; run; data _domain_&amp;domain._all_var; set _domain_&amp;domain._all_var; if upcase(substr(NAME, 1, 2)) eq &quot;&amp;domain&quot; and upcase(substr(NAME, 1, 3)) ne &quot;&amp;domain._&quot; then output; if NAME in (&quot;VISIT&quot; &quot;VISITNUM&quot;) then output; run; *** Check which entries occur either in the specifications or the SAS dataset with domain data but not both (a warning is created for such entries and the entry is outputted in a dataset for tracking); proc sort data=_domain_&amp;domain._all_var(keep=NAME); by NAME; run; data domain_&amp;domain._completeness_chk; merge _domain_&amp;domain._specs_for_chk (in=inSPECS rename=(Type=Type_Specs) where=(Variable_Name not in (&quot;STUDYID&quot; &quot;DOMAIN&quot; &quot;USUBJID&quot;))) _domain_&amp;domain._all_var (in=inDOMAIN rename=(Name=Variable_Name)); by Variable_Name; if inSPECS and not inDOMAIN then do; put &quot;WARNING: Variable &quot; Variable_Name &quot; is part of the specification but not of the final &amp;domain dataset (user-defined)&quot;; NOT_IN_DOMAIN = &quot;Y&quot;; output; end; else if inDOMAIN and not inSPECS then do; put &quot;WARNING: Variable &quot; Variable_Name &quot; is part of the final &amp;domain dataset but not of the specifications (user-defined)&quot;; NOT_IN_SPECS = &quot;Y&quot;; output; end; run; %end; *** Sort the variable names according to the order specified in the metadata (required to have the correct order of variables in the lists defined below); proc sort data=_domain_&amp;domain._specs; by order; run; *** Prepare some variable lists and store each variable list in a macro variable (supp-domain variables are not included); data _NULL_; length domain_var_list /* List with all SDTM variables required for the final domain dataset (i.e. numeric variables are included) */ char_var_list /* List with all character SDTM variables required */ temp_var_list /* List with temporary variables to temporarily store the content of each character SDTM variable (variable name = variables name of character variable + prefix &quot;_&quot;) */ rename_list /* List to rename all SDTM variables for the final domain dataset to the name of the temporary variable (format: XXXXX=_XXXXX) */ label_list /* List for assignment of a label to each SDTM variable required (i.e. numeric variables are included) */ length_var_list $32767. /* List which stores the names of all character SDTM variables after addition of the suffix &quot;_len&quot; (required for assignment of length) */; set _domain_&amp;domain._specs end=eof; retain domain_var_list char_var_list temp_var_list rename_list label_list length_var_list; *** Definition of variable lists; domain_var_list = strip(domain_var_list) || &quot; &quot; || strip(Variable_Name); label_list = strip(label_list) || &quot; &quot; || strip(Variable_Name) || &quot;=&#39;&quot; || strip(Variable_Label) || &quot;&#39;&quot;; if find(upcase(Type), &quot;CHAR&quot;) gt 0 then do; char_var_list = strip(char_var_list) || &quot; &quot; || strip(Variable_Name); temp_var_list = strip(temp_var_list) || &quot; _&quot; || strip(Variable_Name); rename_list = strip(rename_list) || &quot; &quot; || strip(Variable_Name) || &quot;=_&quot; || strip(Variable_Name); length_var_list = strip(length_var_list) || &quot; &quot; || strip(Variable_Name) || &quot;_len&quot;; end; *** Definition of macro variables; if eof then do; call symput(&quot;domain_var_list&quot;, strip(domain_var_list)); call symput(&quot;char_var_list&quot;, strip(char_var_list)); call symput(&quot;temp_var_list&quot;, strip(temp_var_list)); call symput(&quot;rename_list&quot;, strip(rename_list)); call symput(&quot;label_list&quot;, strip(label_list)); call symput(&quot;length_var_list&quot;, strip(length_var_list)); end; run; %put Variable list: &amp;domain_var_list; %put Character variable list: &amp;char_var_list; *** Store the content of all SDTM variables in their temporary counterpart (&quot;_&quot; || variable name); data _domain_&amp;domain; set domain_&amp;domain (rename=(&amp;rename_list)); run; *** Prepare a macro variable with the assignment of length for each character SDTM variable in the final dataset (the length assigned corresponds to the length of the longest entry for the respective SDTM variables (requirement of SDTM); data _NULL_; length _lengths $32767.; set domain_&amp;domain (rename=(&amp;rename_list)) end=eof; retain &amp;length_var_list 0; array temp_var {*} &amp;temp_var_list; array var_len {*} &amp;length_var_list; do var1 = 1 to dim(temp_var); if length(temp_var[var1]) gt var_len[var1] then var_len[var1] = length(temp_var[var1]); end; if eof then do; _lengths = &quot;length &quot;; do var2 = 1 to dim(temp_var); _lengths = strip(_lengths) || &quot; &quot; || substr(vname(temp_var[var2]), 2, length(vname(temp_var[var2]))-1) || &quot; $&quot; || strip(put(var_len[var2], best12.)); end; call symput(&quot;_&amp;domain._lengths&quot;, strip(_lengths)); end; run; %put &amp;&amp;_&amp;domain._lengths; *** Create the prefinal SDTM domain dataset (after this data-step only the correct variable order and sorting of entries is outstanding); data _domain_&amp;domain._prefin; *** Assign correct length to the SDTM variables; &amp;&amp;_&amp;domain._lengths; set _domain_&amp;domain; *** Transfer the data of the temporary SDTM variables (_XXXX) back to the SDTM variables; array temp_var {*} &amp;temp_var_list; array char_var {*} &amp;char_var_list; do var = 1 to dim(temp_var); char_var[var] = strip(temp_var[var]); end; *** Assign labels to all SDTM variables; label &amp;label_list; ; *** Keep only SDTM variables required for the final domain dataset; keep &amp;domain_var_list; run; *** Sort data according to the order given in the specifications; data domain_&amp;domain._new; retain &amp;domain_var_list; set _domain_&amp;domain._prefin; run; *** Sort final domain dataset by USUBJID and, if applicable, sequence number or an other variable; %if &amp;domain eq DM %then %do; proc sort data = domain_&amp;domain._new; by USUBJID; run; %end; %else %if &amp;domain eq SV %then %do; proc sort data = domain_&amp;domain._new; by USUBJID VISITNUM; run; %end; %else %if &amp;domain ne DM %then %do; proc sort data = domain_&amp;domain._new; by USUBJID &amp;domain.SEQ; run; %end;; *** Check whether the variable lengths and the variable types specified in the specifications are consistent with the lengths and types of variables in the final domain dataset and whether any variable exceeds a length of 200 characters; *** Prepare a dataset with all variable names occuring in the final dataset in one column and the corresponding length in another column; proc contents data=domain_&amp;domain._new out=_domain_&amp;domain._real_var_lengths noprint; run; *** Check for which SDTM variables the length / type has to be corrected in the specification file / final dataset and for which SDTM variables the maximal length of 200 characters is exceeded (a warning is created for such entries and the entry is outputted in a dataset for tracking); proc sort data=_domain_&amp;domain._specs; by Variable_Name Display_Format; run; proc sort data=_domain_&amp;domain._real_var_lengths; by Name Length; run; data domain_&amp;domain._lengths; merge _domain_&amp;domain._specs (in=inSPECS rename=(Type=Type_Specs)) _domain_&amp;domain._real_var_lengths (in=inDOMAIN rename=(Name=Variable_Name) keep=NAME TYPE LENGTH LABEL); by Variable_Name; Variable_Name = strip(Variable_Name); *** Prepare warnings; if LENGTH gt 200 then put &quot;WARNING: Length of variable &quot; Variable_Name &quot; is greater 200 (user-defined)&quot;; if LENGTH ne Display_Format then put &quot;WARNING: Length of variable &quot; Variable_Name &quot; in final &amp;domain dataset differs from the length specified in the specifications (user-defined)&quot;; if (TYPE eq 1 and find(upcase(Type_Specs), &quot;NUM&quot;) eq 0) or (TYPE eq 2 and find(upcase(Type_Specs), &quot;CHAR&quot;) eq 0) then put &quot;WARNING: Type of variable &quot; Variable_Name &quot; differs between final &amp;domain dataset and specifications (user-defined)&quot;; *** Output entries for which adaptions are necessary; if LENGTH gt 200 or LENGTH ne Display_Format then LENGTH_ERROR = &quot;Y&quot;; if (TYPE eq 1 and find(upcase(Type_Specs), &quot;NUM&quot;) eq 0) or (TYPE eq 2 and find(upcase(Type_Specs), &quot;CHAR&quot;) eq 0) then TYPE_ERROR = &quot;Y&quot;; run; *** Delete temporary datasets if requested in the macro call; %if &amp;delete ne %then %do; proc datasets lib=work nolist; delete _domain_&amp;domain._specs_for_chk _domain_&amp;domain._specs _domain_&amp;domain _domain_&amp;domain._prefin _domain_&amp;domain._real_var_lengths _domain_&amp;domain._all_var ; quit; %end; %mend create_sdtm_domain; 28.2.8 %DetectDuplicates Detection of duplicate variables %macro DetectDuplicates (dataset, output_diff); proc contents data=&amp;dataset out=var_data (keep=memname name) noprint; run; proc sort data=var_data; by name; run; data _null_; length var_names $32767.; set var_data; retain var_names; retain num_vars 0; if _n_ ne 1 then var_names=strip(var_names) || &quot; &quot; || strip(name); else if _n_ eq 1 then var_names=strip(name); num_vars = num_vars + 1; call symput(&quot;var_names&quot;, strip(var_names)); call symput(&quot;num_vars&quot;, strip(put(num_vars,2.))); run; %put &amp;var_names.; %put &amp;num_vars.; proc sort data=&amp;dataset nodupkey dupout=duplicates; by &amp;var_names; run; %mend DetectDuplicates; %DetectDuplicates (dataset=, output_diff=); %let folder_path1=Z:\\CDISC\\STUDIES\\MEDIWOUND1\\SDTM\\Domains\\20181213\\; %let report_name=Report_Duplicates; dm log &#39;clear&#39;; *** To compare the old datasets in a folder with the new datasets in another folder; %macro DetectDuplicatesFolder (folder_path1, report_name); %if %sysfunc(exist(work.&amp;report_name)) %then %do; proc datasets library=work nolist; delete &amp;report_name; run; %end; filename entry2 pipe &quot;dir &amp;folder_path1 /b&quot;; *** declare macro variables containing the name of a dataset in the specified folder and their overall number; data m_dataset_list; infile entry2 truncover end=last; /* edit length as needed */ length fname $40; input fname; if upcase(substr(strip(fname), 1, 2)) ne &quot;SU&quot;; i+1; if upcase(substr(fname, 1, 2)) eq &quot;M_&quot; then check_m_ = 1; else check_m_ = 0; /* the parsing (splitting) of FNAME may need to be changed depending on your OS*/ call symput(&#39;fname&#39;||trim(left(put(i,8.))),scan(trim(fname),1,&#39;.&#39;)); if last then call symput(&#39;total&#39;,trim(left(put(i,8.)))); run; %put &amp;total.; option spool; *** import by means of the macro variables defined above ; %do i=1 %to &amp;total; libname libdata &quot;&amp;folder_path1&quot;; libname library (libdata); data work.&amp;&amp;fname&amp;i; set libdata.&amp;&amp;fname&amp;i; run; %if %sysfunc(exist(libdata.SUPP&amp;&amp;fname&amp;i)) and &amp;i ne 2 %then %do; data work.&amp;&amp;fname&amp;i; set libdata.&amp;&amp;fname&amp;i; run; data work.supp&amp;&amp;fname&amp;i; set libdata.supp&amp;&amp;fname&amp;i; &amp;&amp;fname&amp;i..SEQ=input(IDVARVAL, best12.); drop IDVARVAL; run; proc transpose data=supp&amp;&amp;fname&amp;i out=supp&amp;&amp;fname&amp;i; by USUBJID &amp;&amp;fname&amp;i..SEQ; var QVAL; ID QNAM; run; proc sort data=SUPP&amp;&amp;fname&amp;i; by USUBJID &amp;&amp;fname&amp;i..SEQ; run; proc sort data=&amp;&amp;fname&amp;i; by USUBJID &amp;&amp;fname&amp;i..SEQ; run; data &amp;&amp;fname&amp;i.._supp; merge &amp;&amp;fname&amp;i SUPP&amp;&amp;fname&amp;i; by USUBJID &amp;&amp;fname&amp;i..SEQ; run; %end; %else %do; data work.&amp;&amp;fname&amp;i.._supp; set libdata.&amp;&amp;fname&amp;i; run; %end; proc contents data=&amp;&amp;fname&amp;i.._supp out=var_data_&amp;i (keep=memname name) noprint; run; proc sort data=var_data_&amp;i; by name; run; data _null_; length var_names $32767.; set var_data_&amp;i; retain var_names; retain num_vars 0; if strip(name) ne strip(upcase(&quot;&amp;&amp;fname&amp;i..SEQ&quot;)) and _n_ ne 1 then var_names=strip(var_names) || &quot; &quot; || strip(name); else if strip(name) ne strip(upcase(&quot;&amp;&amp;fname&amp;i..SEQ&quot;)) and _n_ eq 1 then var_names=strip(name); num_vars = num_vars + 1; call symput(&quot;var_names&quot;, strip(var_names)); call symput(&quot;num_vars&quot;, strip(put(num_vars,2.))); run; %put &amp;var_names; proc sort data=&amp;&amp;fname&amp;i.._supp nodupkey dupout=output&amp;i; by &amp;var_names; run; data &amp;report_name; set %if %sysfunc(exist(work.&amp;report_name)) %then &amp;report_name; output&amp;i (rename=(&amp;&amp;fname&amp;i..SEQ=SEQ)); run; %end; proc export data=&amp;report_name outfile=&quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\SDTM\\Domains\\Validation\\&amp;report_name..csv&quot; label dbms=dlm; delimiter=&#39;;&#39;; run; proc datasets library=work nolist; delete output1 - output&amp;total var_data1 - var_data&amp;total run; quit; %mend DetectDuplicatesFolder; %DetectDuplicatesFolder (folder_path1=Z:\\CDISC\\STUDIES\\MEDIWOUND1\\SDTM\\Domains\\20181213\\, report_name=Report_Duplicates); 28.2.9 %ChangedVarNum Compares the occurrence of variables between two datasets. Where the first dataset/folder path corresponds to the old data and the second dataset/folder path corresponds to the new data. %macro ChangedVarNum (dataset1, dataset2, output); proc contents data=&amp;dataset1 out=var_data1 (keep=memname name) noprint; run; proc sort data=var_data1; by name; run; proc contents data=&amp;dataset2 out=var_data2 (rename=(memname=memname2) keep=memname name) noprint; run; proc sort data=var_data2; by name; run; data &amp;output; * length diffflag $2.; merge var_data1 (in=a) var_data2 (in=b); by name; if (a and not b) or (b and not a); label memname = &quot;Dataset 1&quot; name = &quot;Variable Name&quot; memname2 = &quot;Dataset 2&quot;; run; %mend ChangedVarNum; * %ChangedVarNum (dataset1=Ae, dataset2=Ae_old, output=Ae_compare); To compare the old datasets in a folder with the new datasets in another folder; %macro ChangedVarNumFolder (folder_path1, folder_path2, report_name); %if %sysfunc(exist(work.&amp;report_name)) %then %do; proc datasets library=work nolist; delete &amp;report_name; run; %end; filename entry2 pipe &quot;dir &amp;folder_path1 /b&quot;; *** declare macro variables containing the name of a dataset in the specified folder and their overall number; data m_dataset_list; infile entry2 truncover end=last; /* edit length as needed */ length fname $40; input fname; i+1; if upcase(substr(fname, 1, 2)) eq &quot;M_&quot; then check_m_ = 1; else check_m_ = 0; /* the parsing (splitting) of FNAME may need to be changed depending on your OS*/ call symput(&#39;fname&#39;||trim(left(put(i,8.))),scan(trim(fname),1,&#39;.&#39;)); if last then call symput(&#39;total&#39;,trim(left(put(i,8.)))); run; *** import by means of the macro variables defined above ; %do i=1 %to &amp;total; libname libdata &quot;&amp;folder_path1&quot;; libname library (libdata); data work.&amp;&amp;fname&amp;i.._old; set libdata.&amp;&amp;fname&amp;i; run; libname libdata2 &quot;&amp;folder_path2&quot;; libname library2 (libdata); data work.&amp;&amp;fname&amp;i; set libdata2.&amp;&amp;fname&amp;i; run; proc contents data=&amp;&amp;fname&amp;i.._old out=var_data1_&amp;i (keep=memname name) noprint; run; proc sort data=var_data1_&amp;i; by name; run; proc contents data=&amp;&amp;fname&amp;i out=var_data2_&amp;i (rename=(memname=memname2) keep=memname name) noprint; run; proc sort data=var_data2_&amp;i; by name; run; data output&amp;i; * length diffflag $2.; merge var_data1_&amp;i (in=a) var_data2_&amp;i (in=b); by name; if (a and not b) or (b and not a); label memname = &quot;Dataset 1&quot; name = &quot;Variable Name&quot; memname2 = &quot;Dataset 2&quot;; run; data &amp;report_name; set %if %sysfunc(exist(work.&amp;report_name)) %then &amp;report_name; output&amp;i; run; %end; proc export data=&amp;report_name outfile=&quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\SDTM\\Domains\\Validation\\&amp;report_name..csv&quot; label dbms=dlm; delimiter=&#39;;&#39;; run; proc datasets library=work nolist; delete output1 - output&amp;total var_data1_1 - var_data1_&amp;total var_data2_1 - var_data2_&amp;total run; quit; %mend ChangedVarNumFolder; %ChangedVarNumFolder (folder_path1=Z:\\CDISC\\STUDIES\\MEDIWOUND1\\SDTM\\Domains\\20181123\\, folder_path2=Z:\\CDISC\\STUDIES\\MEDIWOUND1\\SDTM\\Domains\\20191112\\, report_name=Report_VarNum); 28.2.10 %ChangedLabels Compares the labels of variables between two datasets. Where the first dataset/folder path corresponds to the old data and the second dataset/folder path corresponds to the new data. %macro ChangedLabels (dataset1, dataset2, output); proc contents data=&amp;dataset1 out=label_data1 (keep=memname name label) noprint; run; proc sort data=label_data1 ;by name label; run; proc contents data=&amp;dataset2 out=label_data2 (rename=(memname=memname2) keep=memname name label) noprint; run; proc sort data=label_data2; by name label; run; data &amp;output; *length diffflag $2.; merge label_data1 (in=a) label_data2 (in=b); by name label; if (a and not b) or (b and not a); label memname = &quot;Dataset 1&quot; name = &quot;Variable Name&quot; label = &quot;Changed Label&quot; memname2 = &quot;Dataset 2&quot;; run; %mend ChangedLabels; %ChangedLabels(dataset1=, dataset2=, output=); *** To compare the old datasets in a folder with the new datasets in another folder; %macro ChangedLabelsFolder (folder_path1, folder_path2, report_name); %if %sysfunc(exist(work.&amp;report_name)) %then %do; proc datasets library=work nolist; delete &amp;report_name; run; %end; filename entry2 pipe &quot;dir &amp;folder_path1 /b&quot;; *** declare macro variables containing the name of a dataset in the specified folder and their overall number; data m_dataset_list; infile entry2 truncover end=last; /* edit length as needed */ length fname $40; input fname; i+1; if upcase(substr(fname, 1, 2)) eq &quot;M_&quot; then check_m_ = 1; else check_m_ = 0; /* the parsing (splitting) of FNAME may need to be changed depending on your OS*/ call symput(&#39;fname&#39;||trim(left(put(i,8.))),scan(trim(fname),1,&#39;.&#39;)); if last then call symput(&#39;total&#39;,trim(left(put(i,8.)))); run; *** import by means of the macro variables defined above ; %do i=1 %to &amp;total; libname libdata &quot;&amp;folder_path1&quot;; libname library (libdata); data work.&amp;&amp;fname&amp;i.._old; set libdata.&amp;&amp;fname&amp;i; run; libname libdata2 &quot;&amp;folder_path2&quot;; libname library2 (libdata); data work.&amp;&amp;fname&amp;i; set libdata2.&amp;&amp;fname&amp;i; run; proc contents data=&amp;&amp;fname&amp;i.._old out=label_data1_&amp;i (keep=memname name label) noprint; run; proc sort data=label_data1_&amp;i ; by name label; run; proc contents data=&amp;&amp;fname&amp;i out=label_data2_&amp;i (rename=(memname=memname2) keep=memname name label) noprint; run; proc sort data=label_data2_&amp;i ; by name label; run; data output&amp;i; *length diffflag $2.; merge label_data1_&amp;i (in=a) label_data2_&amp;i (in=b); by name label; if (a and not b) or (b and not a); label memname = &quot;Dataset 1&quot; name = &quot;Variable Name&quot; label = &quot;Changed Label&quot; memname2 = &quot;Dataset 2&quot;; run; data &amp;report_name; set %if %sysfunc(exist(work.&amp;report_name)) %then &amp;report_name; output&amp;i; run; %end; proc export data=&amp;report_name outfile=&quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\SDTM\\Domains\\Validation\\&amp;report_name..csv&quot; label dbms=dlm; delimiter=&#39;;&#39;; run; proc datasets library=work nolist; delete output1 - output&amp;total label_data1_1 - label_data1_&amp;total label_data2_1 - label_data2_&amp;total run; quit; %mend ChangedLabelsFolder; *%ChangedLabelsFolder (folder_path1=Z:\\CDISC\\STUDIES\\MEDIWOUND1\\SDTM\\Domains\\20181123\\, folder_path2=Z:\\CDISC\\STUDIES\\MEDIWOUND1\\SDTM\\Domains\\20191112\\, report_name=Report_Labels); 28.3 Analysis Data Model (ADaM) 28.3.1 Compare with SDTM Study Data Tabulations (SDTM)  datasets containing data collected during the study and organized by clinical domain. SDTM SDTM SDTM Analysis Datasets (ADaM)  datasets used for statistical analysis and reporting by the sponsor, submitted in addition to the SDTM domains. ADaM datasets are the authoritative source for all data derivations used in statistical analyses. ADaMSDTM ADaM ADaMSDTMADaM ADaMSDTMADaMADaMSDTM Figure 28.2: Figure: SDTM and ADaM SDTM ADaM Contains the raw source data and limited derived data  Contains the derived data, both variables and observations, and even entire datasets, that are derived from the raw data. May also contain raw source data to facilitate review and sensitivity analysis.  The variables allowed in each domain are restricted by the SDTM model SDTM ADaM specifies core variables to be present in analysis data sets yet additional variables and observations can be added if they are needed for traceability and/or facilitation of analyses, provided that rules about when to derive data as rows and when to derive data as columns are followed. ADaM/ There is no redundancy of variables within SDTM in that a specific variable, such as treatment, is found in only one SDTM domain. SDTMSDTM There is redundancy of variables across different analysis datasets to support analysis. For instance, treatment variable(s) would be expected to be in every analysis dataset.   Generally uses character variables, such as character date strings.  Numeric values are included when needed for analysis purposes, such as numeric date values.  Each domain has a specific topic and contains only those variables related to that topic.  Contains variables and observations that may be obtained from a variety of domains. For example, a responder analysis may be based on information obtained from laboratory, imaging, and /or questionnaire data.  / 28.3.2 4 types of ADaM metadata analysis dataset metadata: ADaM analysis variable metadata: /ADaM analysis parameter value-level metadata: ADaMADaM BDS analysis results metadata:  Abbreviation Title ADSL Subject-level analysis dataset ADAE Adverse event analysis dataset BDS Basic Data Structure 28.3.3 Subject-Level Analysis Dataset (ADSL) The ADSL dataset structure has one record per subject and contains variables such as subject-level population flags, planned and actual treatment variables, demographic information, randomization factors, subgrouping variables, and important dates. ADSL contains required variables (as specified in the ADaMIG) plus other subject-level variables that are important in describing a subjects experience in the trial. The correct location for key endpoints and data that vary overtime during the course of a study is in a BDS dataset. ADSL ADSLADaMIGBDS 28.3.4 The Basic Data Structure (BDS) A BDS contains one or more records per subject, per analysis parameter, per analysis timepoint. Analysis timepoint is conditionally required, depending on the analysis. In situations where there is no analysis timepoint, the structure is one or more records per subject per analysis parameter. This structure contains a central set of variables that describe the analysis parameter (e.g., PARAM and related variables) and contain the value being analyzed. Other variables in the dataset provide more information about the value being analyzed (e.g., the subject identification) or describe and trace the derivation of it (e.g., DTYPE) or enable the analysis (e.g., treatment variables, covariates). The BDS supports parametric and nonparametric analyses such as ANOVA, ANCOVA, categorical analysis, logistic regression, Cochran-Mantel-Haenszel, Wilcoxon rank-sum, time-to-event analysis, etc. It is often optimal to have more than one BDS analysis dataset. BDSPARAMDTYPE BDSANCOVACochran-Mantel-HaenszelWilcoxonBDS Though the BDS supports the majority of statistical analyses, it does not support all statistical analyses. For example, it does not support the simultaneous analysis of multiple dependent (response/outcome) variables or correlation analysis across a range of response variables. The BDS was not designed to support analysis of the incidence of adverse events or other occurrence data. BDS/ BDS 28.3.5 Example Building ADSL Datasets ADaM IGADSL ADSLADSLADaMADSLADSL CREATE EMPTY ADSL DATASET CALLED EMPTY_ADSL; %make_empty_dataset(metadatafile=&amp;metadatafile, dataset=ADSL) merge supplemental qualifiers into DM; %mergsupp(sourcelib=sdtm, domains=DM); CFB ,  Merge CFB, EMPTY_ADSL, and DM with SUPP, convert date, SORT ADSL ACCORDING TO METADATA AND SAVE PERMANENT DATASET; *------------------------------------------------------------*; * ADSL.sas creates the ADaM ADSL data set * as permanent SAS datasets to the ADaM libref. *------------------------------------------------------------*; %include &quot;..\\setup.sas&quot;; **** CREATE EMPTY ADSL DATASET CALLED EMPTY_ADSL; %let metadatafile=&amp;path/data/adam-metadata/adam_metadata.xlsx; %make_empty_dataset(metadatafile=&amp;metadatafile, dataset=ADSL) ** merge supplemental qualifiers into DM; %mergsupp(sourcelib=sdtm, domains=DM); ** find the change from baseline so that responders can be flagged ; ** (2-point improvement in pain at 6 months); %cfb(indata=sdtm.xp, outdata=responders, dayvar=xpdy, avalvar= xpstresn, keepvars=usubjid visitnum chg); data ADSL; merge EMPTY_ADSL DM (in = inDM) responders (in = inresp where=(visitnum=2)) ; by usubjid; * convert RFSTDTC to a numeric SAS date named TRTSDT; * DTC2DTSDTM --DTCSAS; * TRTSDT; %dtc2dt(RFSTDTC, prefix=TRTS ); * create BRTHDT, RANDDT, TRTEDT; %dtc2dt(BRTHDTC, prefix=BRTH); %dtc2dt(RANDDTC, prefix=RAND); %dtc2dt(RFENDTC, prefix=TRTE); * created flags for ITT and safety-evaluable; ittfl = put(randdt, popfl.); saffl = put(trtsdt, popfl.); trt01p = ARM; trt01a = trt01p; trt01pn = input(put(trt01p, $trt01pn.), best.); trt01an = trt01pn; agegr1n = input(put(age, agegr1n.), best.); agegr1 = put(agegr1n, agegr1_.); RESPFL = put((.z &lt;= chg &lt;= -2), _0n1y.); run; **** SORT ADSL ACCORDING TO METADATA AND SAVE PERMANENT DATASET; %make_sort_order(metadatafile=&amp;metadatafile, dataset=ADSL) proc sort data=adsl (keep = &amp;ADSLKEEPSTRING) out=adam.adsl; by &amp;ADSLSORTSTRING; run; 28.3.6 Example Building ADaM Basic Data Structure (BDS) Datasets ADaMBDSADaM IG ADSLBDS-    \\[ \\begin{array}{lllllllll} \\hline \\text { USUBJID } &amp; \\text { XPSEQ } &amp; \\text { XPTESTCD } &amp; \\text { XPTEST } &amp; \\text { XPORRES } &amp; \\text { XPSTRESN } &amp; \\text { VISIT } &amp; \\text { XPDTC } &amp; \\text { XPDY } \\\\ \\hline \\text { UNI101 } &amp; 1 &amp; \\text { XPPAIN } &amp; \\text { Pain Score } &amp; \\text { Severe } &amp; 3 &amp; \\text { Baseline } &amp; 2010-04-02 &amp; 1 \\\\ \\text { UNI101 } &amp; 2 &amp; \\text { XPPAIN } &amp; \\text { Pain Score } &amp; \\text { Moderate } &amp; 2 &amp; 3 \\text { Months } &amp; 2010-07-03 &amp; 93 \\\\ \\text { UNI101 } &amp; 3 &amp; \\text { XPPAIN } &amp; \\text { Pain Score } &amp; \\text { Mild } &amp; 1 &amp; 6 \\text { Months } &amp; 2010-10-10 &amp; 192 \\\\ \\hline \\end{array} \\] %include &quot;setup.sas&quot;; **** CREATE EMPTY ADEF DATASET CALLED EMPTY_ADEF; options mprint ;*symbolgen; %let metadatafile=&amp;path/data/adam-metadata/ADAM_METADATA.xlsx; %make_empty_dataset(metadatafile=&amp;metadatafile,dataset=ADEF) ** calculate changes from baseline for all post-baseline visits; ** CFBADEFWORK.ADEF; *AVALBASECHGABLFL; %cfb(indata=sdtm.xp, outdata=adef, dayvar=xpdy, avalvar=xpstresn); proc sort data = adam.adsl (keep = usubjid siteid country age agegr1 agegr1n sex race randdt trt01p trt01pn ittfl) out = adsl; by usubjid; data adef; merge adef (in = inadef) adsl (in = inadsl); by usubjid ; if not(inadsl and inadef) then put &#39;PROB&#39; &#39;LEM: Missing subject?-- &#39; usubjid= inadef= inadsl= ; rename trt01p = trtp trt01pn = trtpn xptest = param xptestcd = paramcd visit = avisit xporres = avalc ; if inadsl and inadef; avisitn = input(put(visitnum, avisitn.), best.); %dtc2dt(xpdtc, refdt=randdt); retain crit1 &quot;Pain improvement from baseline of at least 2 points&quot;; RESPFL = put((.z &lt;= chg &lt;= -2), _0n1y.); if RESPFL=&#39;Y&#39; then crit1fl = &#39;Y&#39;; else crit1fl = &#39;N&#39;; run; ** assign variable order and labels; data adef; retain &amp;ADEFKEEPSTRING; set EMPTY_ADEF adef; run; **** SORT ADEF ACCORDING TO METADATA AND SAVE PERMANENT DATASET; %make_sort_order(metadatafile=&amp;metadatafile,dataset=ADEF) proc sort data=adef(keep = &amp;ADEFKEEPSTRING) out=adam.adef; by &amp;ADEFSORTSTRING; run; 28.3.7 Example Building ADAE  Adverse Event Analysis Datasets Datasets ADAESDTM AE ADAEAE CREATE EMPTY ADAE DATASET CALLED EMPTY_ADAE; %make_empty_dataset(metadatafile=&amp;metadatafile,dataset=ADAE) Merge with sdtm.ae and conversion *** CQ01NAM ; *---------------------------------------------------------------*; * ADAE.sas creates the ADaM ADAE-structured data set * for AE data (ADAE), saved to the ADaM libref. *---------------------------------------------------------------*; %include &quot;setup.sas&quot;; **** CREATE EMPTY ADAE DATASET CALLED EMPTY_ADAE; options mprint ;*symbolgen; %let metadatafile=&amp;path/data/adam-metadata/ADAM_METADATA.xlsx; %make_empty_dataset(metadatafile=&amp;metadatafile,dataset=ADAE) proc sort data = adam.adsl (keep = usubjid siteid country age agegr1 agegr1n sex race trtsdt trt01a trt01an saffl) out = adsl; by usubjid; data adae; merge sdtm.ae (in = inae) adsl (in = inadsl); by usubjid ; if inae and not inadsl then put &#39;PROB&#39; &#39;LEM: Subject missing from ADSL?-- &#39; usubjid= inae= inadsl= ; rename trt01a = trta trt01an = trtan ; if inadsl and inae; %dtc2dt(aestdtc, prefix=ast, refdt=trtsdt); %dtc2dt(aeendtc, prefix=aen, refdt=trtsdt); *** CQ01NAM; if index(AEDECOD, &#39;PAIN&#39;)&gt;0 or AEDECOD=&#39;HEADACHE&#39; then CQ01NAM = &#39;PAIN EVENT&#39;; else CQ01NAM = &#39; &#39;; aereln = input(put(aerel, $aereln.), best.); aesevn = input(put(aesev, $aesevn.), best.); relgr1n = (aereln); ** group related events (AERELN&gt;0); relgr1 = put(relgr1n, relgr1n.); if astdt&gt;=trtsdt then trtemfl = &#39;Y&#39;; format astdt aendt yymmdd10.; run; ** assign variable order and labels; data adae; retain &amp;adaeKEEPSTRING; set EMPTY_adae adae; run; **** SORT adae ACCORDING TO METADATA AND SAVE PERMANENT DATASET; %make_sort_order(metadatafile=&amp;metadatafile, dataset=ADAE) proc sort data=adae(keep = &amp;adaeKEEPSTRING) out=adam.adae; by &amp;adaeSORTSTRING; run; 28.4 ADaM SAS Macro 28.4.1 %make_define *---------------------------------------------------------------*; * %make_define creates the define.xml file for the SDTM and ADaM. * It creates define.xml based on the contents of a set of metadata * tabs found in an Excel spreadsheet. * * PARAMETERS: * path = System path to where the SDTM or ADaM metadata * file exists as well as where the define.xml * file will be stored. * metadata = The name of the metadata spreadsheet. * * It requires that the following tabs exist in the metadata file: * DEFINE_HEADER_METADATA = define file header metadata * TOC_METADATA = &quot;table of contents&quot; dataset metadata * VARIABLE_METADATA = variable/column level metadata * VALUELEVEL_METADATA = value/parameter level metadata * COMPUTATIONAL_MKETHOD = computational methods * CODELISTS = controlled terminology metadata * ANALYSIS_RESULTS = ADaM analysis metadata. [Only for ADaM define] * EXTERNAL_LINKS = ADaM results file pointers. [Only for ADaM define] *---------------------------------------------------------------*; %macro make_define(path=,metadata=); **** GET DEFINE FILE HEADER INFORMATION METADATA; proc import out = define_header datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet=&quot;DEFINE_HEADER_METADATA&quot;; run; **** DETERMINE IF THIS IS A SDTM DEFINE FILE OR AN ADAM DEFINE FILE **** AND SET THE STANDARD MACRO VARIABLE FOR THE REST OF THE PROGRAM; data _null_; set define_header; if upcase(standard) = &#39;ADAM&#39; then call symput(&#39;standard&#39;,&#39;ADAM&#39;); else if upcase(standard) = &#39;SDTM&#39; then call symput(&#39;standard&#39;,&#39;SDTM&#39;); else put &quot;ERR&quot; &quot;OR: CDISC standard undefined in define_header_metadata&quot;; run; **** GET &quot;TABLE OF CONTENTS&quot; LEVEL DATASET METADATA; proc import out = toc_metadata datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;TOC_METADATA&quot; ; run; **** GET THE VARIABLE METADATA; proc import out = VARIABLE_METADATA datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;VARIABLE_METADATA&quot;; run; **** GET THE CODELIST METADATA; proc import out = codelists datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;CODELISTS&quot; ; run; **** GET THE COMPUTATIONAL METHOD METADATA; proc import out = compmethod datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;COMPUTATION_METHOD&quot; ; run; **** GET THE VALUE LEVEL METADATA; proc import out = valuelevel datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;VALUELEVEL_METADATA&quot; ; run; %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then %do; **** GET THE ANALYSIS RESULTS METADATA; proc import out = analysisresults datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;ANALYSIS_RESULTS&quot; ; run; **** GET THE ANALYSIS RESULTS METADATA; proc import out = externallinks datafile = &quot;&amp;path\\&amp;metadata&quot; dbms=excelcs replace; sheet = &quot;EXTERNAL_LINKS&quot; ; run; %end; **** USE HTMLENCODE ON SOURCE TEXT THAT NEEDS ENCODING FOR PROPER BROWSER REPRESENTATIION; %if &amp;standard=ADAM %then %do; data toc_metadata; length documentation $ 800; set toc_metadata; documentation = htmlencode(documentation); ** convert single quotes to double quotes; documentation = tranwrd(documentation, &quot;&#39;&quot;, &#39;&quot;&#39;); ** convert double quotes to html quote; documentation = tranwrd(trim(documentation), &#39;&quot;&#39;, &#39;&amp;quot;&#39;); format documentation $800.; run; %end; data variable_metadata; length comment $ 2000; set variable_metadata; format comment; informat comment; origin = htmlencode(origin); label = htmlencode(label); comment = htmlencode(comment); **** FOR ADAM, JOIN ORIGIN/&quot;SOURCE&quot; AND COMMENT **** TO FORM &quot;SOURCE/DERIVATION&quot; METADATA; if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin ne &#39;&#39; and comment ne &#39;&#39; then comment = &quot;SOURCE: &quot; || left(trim(origin)) || &quot; DERIVATION: &quot; || left(trim(comment)); else if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin ne &#39;&#39; and comment = &#39;&#39; then comment = &quot;SOURCE: &quot; || left(trim(origin)); if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin = &#39;&#39; and comment ne &#39;&#39; then comment = &quot;DERIVATION: &quot; || left(trim(comment)); run; data codelists; set codelists; codedvalue = htmlencode(codedvalue); translated = htmlencode(translated); run; data compmethod; set compmethod; computationmethod = htmlencode(computationmethod); run; data valuelevel; length comment $ 2000; set valuelevel; format comment; informat comment; origin = htmlencode(origin); label = htmlencode(label); comment = htmlencode(comment); **** FOR ADAM, JOIN ORIGIN/&quot;SOURCE&quot; AND COMMENT **** TO FORM &quot;SOURCE/DERIVATION&quot; METADATA; if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin ne &#39;&#39; and comment ne &#39;&#39; then comment = &quot;SOURCE: &quot; || left(trim(origin)) || &quot; DERIVATION: &quot; || left(trim(comment)); else if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin ne &#39;&#39; and comment = &#39;&#39; then comment = &quot;SOURCE: &quot; || left(trim(origin)); if &quot;&amp;standard&quot; = &quot;ADAM&quot; and origin = &#39;&#39; and comment ne &#39;&#39; then comment = &quot;DERIVATION: &quot; || left(trim(comment)); run; %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then %do; data analysisresults; length programmingcode $800. docleafid $40.; set analysisresults; where displayid ne &#39;&#39;; arrow + 1; selectioncriteria = htmlencode(selectioncriteria); paramlist = htmlencode(paramlist); reason = htmlencode(reason); documentation = htmlencode(documentation); if index(documentation, &#39;[r]&#39;)&gt;0 then docleafid = substr(documentation, index(documentation,&#39;[r]&#39;)+3, index(documentation,&#39;[\\r]&#39;)-index(documentation,&#39;[r]&#39;)-3); else docleafid = &#39;.&#39;; programmingcode = htmlencode(programmingcode); ** convert single quotes to double quotes; programmingcode = tranwrd(programmingcode, &quot;&#39;&quot;, &#39;&quot;&#39;); ** convert double quotes to html quote; programmingcode = tranwrd(programmingcode, &#39;&quot;&#39;, &#39;&amp;quot;&#39;); format programmingcode $800.; run; ** ENSURE UNIQUENESS ON DISPLAYID AND RESULTID AND CREATE A COMBO ID; data analysisresults; set analysisresults; by displayid notsorted; drop resultnum; retain resultnum; if first.displayid then resultnum = 0; resultnum + 1; if not(first.displayid and last.displayid) then arid = trim(displayid) || &quot;.R.&quot; || put(resultnum,z2.); else arid = displayid; run; ** IF DOCLEAFID IS NON-MISSING, MERGE IN THE TITLE FROM EXTERNAL_LINKS; proc sort data = analysisresults; by docleafid; run; proc sort data = externallinks (keep = leafid title rename=(leafid=docleafid title=doctitle)) out = doc_links; by docleafid; run; data analysisresults; merge analysisresults (in = inar) doc_links (in = indoc_links); by docleafid; if inar; ** if the leaf ID exists, then the title of the leaf ID will be printed and can be removed from DOCUMENTIATION; if indoc_links then documentation = tranwrd(documentation, &#39;[r]&#39; || trim(docleafid) || &#39;[\\r]&#39;, &quot; &quot;); run; proc sort data = analysisresults; by arrow; run; %end; **** CREATE DEFINE FILE HEADER SECTION; filename dheader &quot;&amp;path\\define_header.txt&quot;; data define_header; set define_header; file dheader notitles; creationdate = compress(put(datetime(), IS8601DT.)); put @1 &#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt;&#39; / @1 &#39;&lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;&#39; stylesheet +(-1) &#39;&quot;?&gt;&#39; / @1 &#39;&lt;!-- ******************************************************************************* --&gt;&#39; / @1 &#39;&lt;!-- File: define.xml --&gt;&#39; / @1 &quot;&lt;!-- Date: &amp;sysdate9. --&gt;&quot; / @1 &#39;&lt;!-- Description: Define.xml file for &#39; studyname +(-1) &#39; --&gt;&#39; / @1 &#39;&lt;!-- ******************************************************************************* --&gt;&#39; / @1 &#39;&lt;ODM&#39; / @3 &#39;xmlns=&quot;http://www.cdisc.org/ns/odm/v1.2&quot;&#39; / @3 &#39;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&#39; / @3 &#39;xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&#39; / @3 &#39;xmlns:def=&quot;http://www.cdisc.org/ns/def/v1.0&quot;&#39; / %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then @3 &#39;xmlns:adamref=&quot;http://www.cdisc.org/ns/ADaMRes/DRAFT&quot;&#39; / ; @3 &#39;xsi:schemaLocation=&quot;&#39; schemalocation +(-1) &#39;&quot;&#39; / @3 &#39;FileOID=&quot;&#39; fileoid +(-1) &#39;&quot;&#39; / @3 &#39;ODMVersion=&quot;1.2&quot;&#39; / @3 &#39;FileType=&quot;Snapshot&quot;&#39; / @3 &#39;CreationDateTime=&quot;&#39; creationdate +(-1) &#39;&quot;&gt;&#39; / @1 &#39;&lt;Study OID=&quot;&#39; studyoid +(-1) &#39;&quot;&gt;&#39; / @3 &#39;&lt;GlobalVariables&gt;&#39; / @5 &#39;&lt;StudyName&gt;&#39; studyname +(-1) &#39;&lt;/StudyName&gt;&#39; / @5 &#39;&lt;StudyDescription&gt;&#39; studydescription +(-1) &#39;&lt;/StudyDescription&gt;&#39; / @5 &#39;&lt;ProtocolName&gt;&#39; protocolname +(-1) &#39;&lt;/ProtocolName&gt;&#39; / @3 &#39;&lt;/GlobalVariables&gt;&#39; / @3 &#39;&lt;MetaDataVersion OID=&quot;CDISC.&#39; standard +(-1) &#39;.&#39; version +(-1) &#39;&quot;&#39; / @5 &#39;Name=&quot;&#39; studyname +(-1) &#39;,Data Definitions&quot;&#39; / @5 &#39;Description=&quot;&#39; studyname +(-1) &#39;,Data Definitions&quot;&#39; / @5 &#39;def:DefineVersion=&quot;1.0.0&quot;&#39; / @5 &#39;def:StandardName=&quot;CDISC &#39; standard +(-1) &#39;&quot;&#39; / @5 &#39;def:StandardVersion=&quot;&#39; version +(-1) &#39;&quot;&gt;&#39; / %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then %do; @5 &#39;&lt;def:SupplementalDoc&gt;&#39; / @7 &#39;&lt;def:DocumentRef leafID=&quot;Suppdoc&quot;/&gt;&#39; / @5 &#39;&lt;/def:SupplementalDoc&gt;&#39; / @5 &#39;&lt;def:leaf ID=&quot;Suppdoc&quot; xlink:href=&quot;dataguide.pdf&quot;&gt;&#39; / @7 &#39;&lt;def:title&gt;Data Guide&lt;/def:title&gt;&#39; / %end; %else %if &quot;&amp;standard&quot; = &quot;SDTM&quot; %then %do; @5 &#39;&lt;def:AnnotatedCRF&gt;&#39; / @7 &#39;&lt;def:DocumentRef leafID=&quot;blankcrf&quot;/&gt;&#39; / @5 &#39;&lt;/def:AnnotatedCRF&gt;&#39; / @5 &#39;&lt;def:leaf ID=&quot;blankcrf&quot; xlink:href=&quot;blankcrf.pdf&quot;&gt;&#39; / @7 &#39;&lt;def:title&gt;Annotated Case Report Form&lt;/def:title&gt;&#39; / %end; @5 &#39;&lt;/def:leaf&gt;&#39;; run; **** ADD OTHER ADAM EXTERNAL LINKS; %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then %do; filename leaves &quot;&amp;path\\leaves.txt&quot;; data _null_; set externallinks; file leaves notitles; put @5 &#39;&lt;def:leaf ID=&quot;&#39; leafid +(-1) &#39;&quot;&#39; / @7 &#39;xlink:href=&quot;&#39; leafrelpath +(-1) &#39;&quot;&gt;&#39; / @7 &#39;&lt;def:title&gt;&#39; title &#39;&lt;/def:title&gt;&#39; / @5 &#39;&lt;/def:leaf&gt;&#39; ; run; %end; **** ADD ITEMOID TO VARIABLE METADATA; data variable_metadata; set variable_metadata(rename=(domain = oid)); length itemoid $ 40; if variable in (&quot;STUDYID&quot;,&quot;DOMAIN&quot;,&quot;USUBJID&quot;,&quot;SUBJID&quot;) then itemoid = variable; else itemoid = compress(oid || &quot;.&quot; || variable); run; **** ADD ITEMOID TO VALUE LEVEL METADATA; data valuelevel; set valuelevel; length itemoid $ 200; itemoid = compress(valuelistoid || &quot;.&quot; || valuename); run; **** CREATE COMPUTATION METHOD SECTION; filename comp &quot;&amp;path\\compmethod.txt&quot;; data compmethods; set compmethod; file comp notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ******************************************* --&gt;&quot; / @5 &quot;&lt;!-- COMPUTATIONAL METHOD INFORMATION *** --&gt;&quot; / @5 &quot;&lt;!-- ******************************************* --&gt;&quot;; put @5 &#39;&lt;def:ComputationMethod OID=&quot;&#39; computationmethodoid +(-1) &#39;&quot;&gt;&#39; computationmethod +(-1) &#39;&lt;/def:ComputationMethod&gt;&#39;; run; **** CREATE VALUE LEVEL LIST DEFINITION SECTION; proc sort data=valuelevel; where valuelistoid ne &#39;&#39;; by valuelistoid; run; filename vallist &quot;&amp;path\\valuelist.txt&quot;; data valuelevel; set valuelevel; by valuelistoid; file vallist notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ******************************************* --&gt;&quot; / @5 &quot;&lt;!-- VALUE LEVEL LIST DEFINITION INFORMATION ** --&gt;&quot; / @5 &quot;&lt;!-- ******************************************* --&gt;&quot;; if first.valuelistoid then put @5 &#39;&lt;def:ValueListDef OID=&quot;&#39; valuelistoid +(-1) &#39;&quot;&gt;&#39;; put @7 &#39;&lt;ItemRef ItemOID=&quot;&#39; itemoid /*valuename*/ +(-1) &#39;&quot;&#39; / @9 &#39;Mandatory=&quot;&#39; mandatory +(-1) &#39;&quot;/&gt;&#39;; if last.valuelistoid then put @5 &#39;&lt;/def:ValueListDef&gt;&#39;; run; **** CREATE &quot;ITEMGROUPDEF&quot; SECTION; proc sort data=VARIABLE_METADATA; where oid ne &#39;&#39;; by oid varnum; run; proc sort data=toc_metadata; where oid ne &#39;&#39;; by oid; run; filename igdef &quot;&amp;path\\itemgroupdef.txt&quot;; data itemgroupdef; length label $ 40; merge toc_metadata VARIABLE_METADATA(drop=label); by oid; file igdef notitles; if first.oid then do; put @5 &quot;&lt;!-- ******************************************* --&gt;&quot; / @5 &quot;&lt;!-- &quot; oid @25 &quot;ItemGroupDef INFORMATION *** --&gt;&quot; / @5 &quot;&lt;!-- ******************************************* --&gt;&quot; / @5 &#39;&lt;ItemGroupDef OID=&quot;&#39; oid +(-1) &#39;&quot;&#39; / @7 &#39;Name=&quot;&#39; name +(-1) &#39;&quot;&#39; / @7 &#39;Repeating=&quot;&#39; repeating +(-1) &#39;&quot;&#39; / @7 &#39;Purpose=&quot;&#39; purpose +(-1) &#39;&quot;&#39; / @7 &#39;IsReferenceData=&quot;&#39; isreferencedata +(-1) &#39;&quot;&#39; / @7 &#39;def:Label=&quot;&#39; label +(-1) &#39;&quot;&#39; / @7 &#39;def:Structure=&quot;&#39; structure +(-1) &#39;&quot;&#39; / @7 &#39;def:DomainKeys=&quot;&#39; domainkeys +(-1) &#39;&quot;&#39; / @7 &#39;def:Class=&quot;&#39; class +(-1) &#39;&quot;&#39; ; %if &amp;standard=ADAM %then put @7 &#39;def:ArchiveLocationID=&quot;Location.&#39; archivelocationid +(-1) &#39;&quot;&#39; / @7 &#39;Comment=&quot;&#39; documentation +(-1) &#39;&quot;&gt;&#39; ; %else put @7 &#39;def:ArchiveLocationID=&quot;Location.&#39; archivelocationid +(-1) &#39;&quot;&gt;&#39;; ; end; put @7 &#39;&lt;ItemRef ItemOID=&quot;&#39; itemoid +(-1) &#39;&quot;&#39; / @9 &#39;OrderNumber=&quot;&#39; varnum +(-1) &#39;&quot;&#39; / @9 &#39;Mandatory=&quot;&#39; mandatory +(-1) @; if role ne &#39;&#39; and &quot;&amp;standard&quot; = &quot;SDTM&quot; then put &#39;&quot;&#39; / @9 &#39;Role=&quot;&#39; role +(-1) &#39;&quot;&#39; / @9 &#39;RoleCodeListOID=&quot;CodeList.&#39; rolecodelist +(-1) &#39;&quot;/&gt;&#39;; else put &#39;&quot;/&gt;&#39;; if last.oid then put @7 &quot;&lt;!-- **************************************************** --&gt;&quot; / @7 &quot;&lt;!-- def:leaf details for hypertext linking the dataset --&gt;&quot; / @7 &quot;&lt;!-- **************************************************** --&gt;&quot; / @7 &#39;&lt;def:leaf ID=&quot;Location.&#39; oid +(-1) &#39;&quot; xlink:href=&quot;&#39; archivelocationid +(-1) &#39;.xpt&quot;&gt;&#39; / @9 &#39;&lt;def:title&gt;&#39; archivelocationid +(-1) &#39;.xpt &lt;/def:title&gt;&#39; / @7 &#39;&lt;/def:leaf&gt;&#39; / @5 &#39;&lt;/ItemGroupDef&gt;&#39;; run; **** CREATE &quot;ITEMDEF&quot; SECTION; filename idef &quot;&amp;path\\itemdef.txt&quot;; data itemdef; set VARIABLE_METADATA end=eof; by oid; file idef notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; / @5 &quot;&lt;!-- The details of each variable is here for all domains --&gt;&quot; / @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; ; put @5 &#39;&lt;ItemDef OID=&quot;&#39; itemoid +(-1) &#39;&quot;&#39; / @7 &#39;Name=&quot;&#39; variable +(-1) &#39;&quot;&#39; / @7 &#39;DataType=&quot;&#39; type +(-1) &#39;&quot;&#39; / @7 &#39;Length=&quot;&#39; length +(-1) &#39;&quot;&#39;; if significantdigits ne &#39;&#39; then put @7 &#39;SignificantDigitis=&quot;&#39; significantdigits +(-1) &#39;&quot;&#39;; if displayformat ne &#39;&#39; then put @7 &#39;def:DisplayFormat=&quot;&#39; displayformat +(-1) &#39;&quot;&#39;; if computationmethodoid ne &#39;&#39; then put @7 &#39;def:ComputationMethodOID=&quot;&#39; computationmethodoid +(-1) &#39;&quot;&#39;; put %if &quot;&amp;standard&quot; = &quot;SDTM&quot; %then @7 &#39;Origin=&quot;&#39; origin +(-1) &#39;&quot;&#39; / ; @7 &#39;Comment=&quot;&#39; comment +(-1) &#39;&quot;&#39; / @7 &#39;def:Label=&quot;&#39; label +(-1) &#39;&quot;&gt;&#39;; if codelistname ne &#39;&#39; then put @7 &#39;&lt;CodeListRef CodeListOID=&quot;CodeList.&#39; codelistname +(-1) &#39;&quot;/&gt;&#39;; if valuelistoid ne &#39;&#39; then put @7 &#39;&lt;def:ValueListRef ValueListOID=&quot;&#39; valuelistoid +(-1) &#39;&quot;/&gt;&#39;; put @5 &#39;&lt;/ItemDef&gt;&#39;; run; **** ADD ITEMDEFS FOR VALUE LEVEL ITEMS TO &quot;ITEMDEF&quot; SECTION; filename idefvl &quot;&amp;path\\itemdef_value.txt&quot;; data itemdefvalue; set valuelevel end=eof; by valuelistoid; file idefvl notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; / @5 &quot;&lt;!-- The details of value level items are here --&gt;&quot; / @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; ; put @5 &#39;&lt;ItemDef OID=&quot;&#39; itemoid /*valuename*/ +(-1) &#39;&quot;&#39; / @7 &#39;Name=&quot;&#39; valuename +(-1) &#39;&quot;&#39; / @7 &#39;DataType=&quot;&#39; type +(-1) &#39;&quot;&#39; / @7 &#39;Length=&quot;&#39; length +(-1) &#39;&quot;&#39;; if significantdigits ne &#39;&#39; then put @7 &#39;SignificantDigitis=&quot;&#39; significantdigits +(-1) &#39;&quot;&#39;; if displayformat ne &#39;&#39; then put @7 &#39;def:DisplayFormat=&quot;&#39; displayformat +(-1) &#39;&quot;&#39;; if computationmethodoid ne &#39;&#39; then put @7 &#39;def:ComputationMethodOID=&quot;&#39; computationmethodoid +(-1) &#39;&quot;&#39;; put %if &quot;&amp;standard&quot; = &quot;SDTM&quot; %then @7 &#39;Origin=&quot;&#39; origin +(-1) &#39;&quot;&#39; / ; @7 &#39;Comment=&quot;&#39; comment +(-1) &#39;&quot;&#39; / @7 &#39;def:Label=&quot;&#39; label +(-1) &#39;&quot;&gt;&#39;; if codelistname ne &#39;&#39; then put @7 &#39;&lt;CodeListRef CodeListOID=&quot;CodeList.&#39; codelistname +(-1) &#39;&quot;/&gt;&#39;; put @5 &#39;&lt;/ItemDef&gt;&#39;; run; **** ADD ANALYSIS RESULTS METADATA SECTION FOR ADAM; %if &quot;&amp;standard&quot; = &quot;ADAM&quot; %then %do; filename ar &quot;&amp;path\\analysisresults.txt&quot;; data _null_; set analysisresults; ** note that it is required that identical display IDs be adjacent to ** each other in the metadata spreadsheet; by displayid notsorted; file ar notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; / @5 &quot;&lt;!-- Analysis Results MetaData are Presented Below --&gt;&quot; / @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; ; if first.displayid then put @5 &#39;&lt;adamref:AnalysisResultDisplays&gt;&#39; / @7 &#39;&lt;adamref:ResultDisplay DisplayIdentifier=&quot;&#39; displayid +(-1) &#39;&quot; OID=&quot;&#39; displayid +(-1) &#39;&quot; DisplayLabel=&quot;&#39; displayname +(-1) &#39;&quot; leafID=&quot;&#39; displayid +(-1) &#39;&quot;&gt;&#39; ; put @9 &#39;&lt;adamref:AnalysisResults &#39; / @9 &#39;OID=&quot;&#39; arid +(-1) &#39;&quot;&#39; / @9 &#39;ResultIdentifier=&quot;&#39; resultid +(-1) &#39;&quot;&#39; / @9 &#39;Reason=&quot;&#39; reason +(-1) &#39;&quot;&gt;&#39; / @9 &#39;&lt;!-- List the parameters and parameter codes --&gt;&#39; / @9 &#39;&lt;adamref:ParameterList&gt;&#39; ; ** loop through PARAMCD/PARAM sets; set = 1; do while(scan(paramlist,set,&#39;|&#39;) ne &#39;&#39;); paramset = scan(paramlist,set,&#39;|&#39;); paramcd = scan(paramset,1,&#39;/\\&#39;); param = trim(scan(paramset,2,&#39;/\\&#39;)); put @11 &#39;&lt;adamref:Parameter ParamCD=&quot;&#39; paramcd +(-1) &#39;&quot; Param=&quot;&#39; param +(-1) &#39;&quot;/&gt;&#39; ; set = set + 1; end; put @9 &#39;&lt;/adamref:ParameterList&gt;&#39;; ** loop through the analysis variables; set = 1; do while(scan(analysisvariables,set,&#39;,&#39;) ne &#39;&#39;); analysisvar = scan(analysisvariables,set,&#39;,&#39;); put @11 &#39;&lt;adamref:AnalysisVariable ItemOID=&quot;&#39; analysisdataset +(-1) &#39;.&#39; analysisvar +(-1) &#39;&quot;/&gt;&#39;; set = set + 1; end; put @9 &#39;&lt;!-- AnalysisDatasets are pairs of dataset references and selection criteria. Dataset references are ItemGroupRefs. The label in the xsl is the def:label for the ItemGroup --&gt;&#39;; put @9 &#39;&lt;adamref:AnalysisDataset&gt;&#39; / @11 &#39;&lt;ItemGroupRef ItemGroupOID=&quot;&#39; analysisdataset +(-1) &#39;&quot; Mandatory=&quot;No&quot;/&gt;&#39; / @11 &#39;&lt;adamref:SelectionCriteria&gt;&#39; / /* just use the row number of the data set as the unique number for the selection criteria */ @13 &#39;&lt;def:ComputationMethod OID=&quot;SC&#39; _n_ z3. &#39;&quot; Name=&quot;Selection Criteria &#39; _n_ z3. &#39;&quot;&gt; [&#39; selectioncriteria &#39; ]&lt;/def:ComputationMethod&gt; &#39;/ @11 &#39;&lt;/adamref:SelectionCriteria&gt; &#39; / @9 &#39;&lt;/adamref:AnalysisDataset&gt; &#39; / @9 &#39;&lt;adamref:Documentation leafID=&quot;&#39; docleafid +(-1) &#39;&quot;&gt;&#39; / @11 &#39;&lt;TranslatedText xml:lang=&quot;en&quot;&gt;&#39; Documentation / @11 &#39;&lt;/TranslatedText&gt;&#39; / @9 &#39;&lt;/adamref:Documentation&gt;&#39; / @9 &#39;&lt;adamref:ProgrammingCode&gt;&#39; / @9 &#39;&lt;def:ComputationMethod OID=&quot;&#39; displayid +(-1) &#39;&quot;&gt;&#39; / @1 ProgrammingCode / @9 &#39;&lt;/def:ComputationMethod&gt;&#39; / @9 &#39;&lt;/adamref:ProgrammingCode&gt;&#39; / @7 &#39;&lt;/adamref:AnalysisResults&gt;&#39; ; if last.displayid then put @5 &#39;&lt;/adamref:ResultDisplay&gt;&#39; / @5 &#39;&lt;/adamref:AnalysisResultDisplays&gt;&#39; ; run; %end; **** CREATE CODELIST SECTION; filename codes &quot;&amp;path\\codelist.txt&quot;; proc sort data=codelists nodupkey; by codelistname codedvalue translated; run; **** MAKE SURE CODELIST IS UNIQUE; data _null_; set codelists; by codelistname codedvalue; if not (first.codedvalue and last.codedvalue) then put &quot;ERR&quot; &quot;OR: multiple versions of the same coded value &quot; codelistname= codedvalue=; run; proc sort data=codelists; by codelistname rank; run; data codelists; set codelists end=eof; by codelistname rank; file codes notitles; if _n_ = 1 then put @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; / @5 &quot;&lt;!-- Codelists are presented below --&gt;&quot; / @5 &quot;&lt;!-- ************************************************************ --&gt;&quot; ; if first.codelistname then put @5 &#39;&lt;CodeList OID=&quot;CodeList.&#39; codelistname +(-1) &#39;&quot;&#39; / @7 &#39;Name=&quot;&#39; codelistname +(-1) &#39;&quot;&#39; / @7 &#39;DataType=&quot;&#39; type +(-1) &#39;&quot;&gt;&#39;; **** output codelists that are not external dictionaries; if codelistdictionary = &#39;&#39; then do; put @7 &#39;&lt;CodeListItem CodedValue=&quot;&#39; codedvalue +(-1) &#39;&quot;&#39; @; if rank ne . then put &#39; def:Rank=&quot;&#39; rank +(-1) &#39;&quot;&gt;&#39;; else put &#39;&gt;&#39;; put @9 &#39;&lt;Decode&gt;&#39; / @11 &#39;&lt;TranslatedText&gt;&#39; translated +(-1) &#39;&lt;/TranslatedText&gt;&#39; / @9 &#39;&lt;/Decode&gt;&#39; / @7 &#39;&lt;/CodeListItem&gt;&#39;; end; **** output codelists that are pointers to external codelists; if codelistdictionary ne &#39;&#39; then put @7 &#39;&lt;ExternalCodeList Dictionary=&quot;&#39; codelistdictionary +(-1) &#39;&quot; Version=&quot;&#39; codelistversion +(-1) &#39;&quot;/&gt;&#39;; if last.codelistname then put @5 &#39;&lt;/CodeList&gt;&#39;; if eof then put @3 &#39;&lt;/MetaDataVersion&gt;&#39; / @1 &#39;&lt;/Study&gt;&#39; / @1 &#39;&lt;/ODM&gt;&#39;; run; ** create the .BAT file that will put all of the files together to create the define; filename dotbat &quot;make_define.bat&quot;; data _null_; file dotbat notitles; drive = substr(&quot;&amp;path&quot;,1,2); put @1 drive; put @1 &quot;cd &amp;path&quot;; if &quot;&amp;standard&quot; = &quot;ADAM&quot; then put @1 &quot;type define_header.txt leaves.txt compmethod.txt valuelist.txt itemgroupdef.txt itemdef.txt itemdef_value.txt analysisresults.txt codelist.txt &gt; define.xml&quot;; else if &quot;&amp;standard&quot; = &quot;SDTM&quot; then put @1 &quot;type define_header.txt leaves.txt compmethod.txt valuelist.txt itemgroupdef.txt itemdef.txt itemdef_value.txt codelist.txt &gt; define.xml&quot;; put @1 &quot;exit&quot;; run; x &quot;make_define&quot;; %mend make_define; 28.4.2 %create_adam_dataset Macro to create an ADaMIG-conform dataset, Furthermore, the following validation checks are done: Correct length of variables in specification sheet Variables with length &gt; 200 Discrepancies in variable type between specification sheet and dataset Discrepancies in variables between specification sheet and dataset Title Title metadatafile Name of specification file (usually imported by init-program adam_dataset Input dataset sort_key Variables used for sorting of the final ADaM dataset (optional) delete Indicate whether temporary datasets should be deleted (deletion is done if delete is not empty) Content Content Input SAS dataset with all variables required for the ADaM dataset Output ADaM datasets in SAS7BDAT-format (ADXX_new) Datasets with results of the validation checks ADXX_completeness_chk ADXX_length /***************************************************************************************************************************** Programme name: M_create_adam_dataset Programme language: SAS 9.4 Initial date: 24JUL2020 Sponsor | study: - Author(s): DN ****************************************************************************************************************************** Short description: Macro to create an ADaMIG-conform dataset Furthermore, the following validation checks are done: 1) Correct length of variables in specification sheet 2) Variables with length &gt; 200 3) Discrepancies in variable type between specification sheet and dataset 4) Discrepancies in variables between specification sheet and dataset Requirements: Risk assessment: Low ****************************************************************************************************************************** Input: SAS dataset with all variables required for the ADaM dataset Output: ADaM datasets in SAS7BDAT-format (ADXX_new) Datasets with results of the validation checks - ADXX_completeness_chk - ADXX_length Required programmes: ****************************************************************************************************************************** Document history : Version Date Author Purpose V01_0_0 15OCT2020 DN First initiation based on macro create_sdtm_domain ******************************************************************************************************************************/ ****************************************************************************************************************************** ************************************************* Macro Start **************************************************** ******************************************************************************************************************************; *** Create final domain dataset; %macro create_adam_dataset (metadatafile, /* Name of specification file (usually imported by init-program) */ adam_dataset, /* Input dataset */ sort_key, /* Variables used for sorting of the final ADaM dataset (optional) */ delete /* Indicate whether temporary datasets should be deleted (deletion is done if delete is not empty) */ ); *** Extract metadata, relevant for creation of the ADaM dataset, from the specification sheet; data _&amp;adam_dataset._specs; length Variable_Name $32.; set &amp;metadatafile (where=(strip(upcase(Dataset_Name)) eq upcase(&quot;&amp;adam_dataset&quot;))); order = input(Num, best12.); keep order Variable_Name Variable_Label Variable_Type Display_Format; run; *** Extract metadata, relevant for consistency checks, from the specification sheet; data _&amp;adam_dataset._specs_for_chk; length Variable_Name $32.; set &amp;metadatafile (where=(Dataset_Name eq &quot;&amp;adam_dataset&quot;)); order = input(Num, best12.); keep order Variable_Name Variable_Label Variable_Type Display_Format; run; *** Sort metadata for consistency checks; proc sort data=_&amp;adam_dataset._specs_for_chk; by Variable_Name; run; *** Check whether all ADaM variables defined in the specification sheet are in the SAS dataset with ADaM data; *** Get a dataset with a column which lists all variable names in the SAS dataset with ADaM data; proc contents data=&amp;adam_dataset._fin out=_&amp;adam_dataset._all_var noprint; run; *** Sort for merge; proc sort data=_&amp;adam_dataset._all_var(keep=NAME); by NAME; run; data _&amp;adam_dataset._all_var; set _&amp;adam_dataset._all_var; run; *** Check for completeness (SAS dataset with ADaM data only), create a warning (if applicable) and output the entry in a dataset for tracking; data &amp;adam_dataset._completeness_chk; merge _&amp;adam_dataset._specs_for_chk (in=inSPECS rename=(Variable_Type=Type_Specs)) _&amp;adam_dataset._all_var (in=inADaM rename=(Name=Variable_Name)); by Variable_Name; if inSPECS and not inADaM then do; put &quot;WARNING: Variable &quot; Variable_Name &quot; is part of the specification but not of the final &amp;adam_dataset dataset (user-defined)&quot;; NOT_IN_DATASET = &quot;Y&quot;; output; end; run; *** Sort the variable names according to the order specified in the metadata (required to have the correct order of variables in the lists defined below); proc sort data=_&amp;adam_dataset._specs; by order; run; options noquotelenmax; *** Prepare some variable lists and store each variable list in a macro variable;; data _NULL_; length dataset_var_list /* List with all ADaM variables required for the final ADaM dataset (i.e. numeric variables are included) */ char_var_list /* List with all character ADaM variables required */ temp_var_list /* List with temporary variables to temporarily store the content of each character ADaM variable (variable name = variables name of character variable + prefix &quot;_&quot;) */ rename_list /* List to rename all ADaM variables for the final ADaM dataset to the name of the temporary variable (format: XXXXX=_XXXXX) */ label_list /* List for assignment of a label to each ADaM variable required (i.e. numeric variables are included) */ length_var_list $32767. /* List which stores the names of all character ADaM variables after addition of the suffix &quot;_len&quot; (required for assignment of length) */; set _&amp;adam_dataset._specs end=eof; retain dataset_var_list char_var_list temp_var_list rename_list label_list length_var_list; *** Definition of variable lists; dataset_var_list = strip(dataset_var_list) || &quot; &quot; || strip(Variable_Name); label_list = strip(label_list) || &quot; &quot; || strip(Variable_Name) || &quot;=&#39;&quot; || strip(Variable_Label) || &quot;&#39;&quot;; if find(upcase(Variable_Type), &quot;CHAR&quot;) gt 0 then do; char_var_list = strip(char_var_list) || &quot; &quot; || strip(Variable_Name); temp_var_list = strip(temp_var_list) || &quot; _&quot; || strip(Variable_Name); rename_list = strip(rename_list) || &quot; &quot; || strip(Variable_Name) || &quot;=_&quot; || strip(Variable_Name); length_var_list = strip(length_var_list) || &quot; &quot; || strip(Variable_Name) || &quot;_len&quot;; end; *** Definition of macro variables; if eof then do; call symput(&quot;dataset_var_list&quot;, strip(dataset_var_list)); call symput(&quot;char_var_list&quot;, strip(char_var_list)); call symput(&quot;temp_var_list&quot;, strip(temp_var_list)); call symput(&quot;rename_list&quot;, strip(rename_list)); call symput(&quot;label_list&quot;, strip(label_list)); call symput(&quot;length_var_list&quot;, strip(length_var_list)); end; run; %put Variable list: &amp;dataset_var_list; %put Character variable list: &amp;char_var_list; *** Store the content of all ADaM variables in their temporary counterpart (&quot;_&quot; || variable name); data _&amp;adam_dataset; set &amp;adam_dataset._fin (rename=(&amp;rename_list)); run; *** Prepare a macro variable with the assignment of length for each character ADaM variable in the final dataset (the length assigned corresponds to the length of the longest entry for the respective ADaM variables (requirement of ADaM); data _NULL_; length _lengths $32767.; set &amp;adam_dataset._fin (rename=(&amp;rename_list)) end=eof; retain &amp;length_var_list 0; array temp_var {*} &amp;temp_var_list; array var_len {*} &amp;length_var_list; do var1 = 1 to dim(temp_var); if length(temp_var[var1]) gt var_len[var1] then var_len[var1] = length(temp_var[var1]); end; if eof then do; _lengths = &quot;length &quot;; do var2 = 1 to dim(temp_var); _lengths = strip(_lengths) || &quot; &quot; || substr(vname(temp_var[var2]), 2, length(vname(temp_var[var2]))-1) || &quot; $&quot; || strip(put(var_len[var2], best12.)); end; call symput(&quot;_&amp;adam_dataset._lengths&quot;, strip(_lengths)); end; run; %put &amp;&amp;_&amp;adam_dataset._lengths; *** Create the prefinal ADaM dataset (after this data-step only the correct variable order and sorting of entries is outstanding); data _&amp;adam_dataset._prefin; *** Assign correct length to the ADaM variables; &amp;&amp;_&amp;adam_dataset._lengths; set _&amp;adam_dataset; *** Transfer the data of the temporary ADaM variables (_XXXX) back to the ADaM variables; array temp_var {*} &amp;temp_var_list; array char_var {*} &amp;char_var_list; do var = 1 to dim(temp_var); char_var[var] = strip(temp_var[var]); end; *** Assign labels to all ADaM variables; label &amp;label_list; ; *** Keep only ADaM variables required for the final ADaM dataset; keep &amp;dataset_var_list; run; *** Sort data according to the order given in the specifications; data &amp;adam_dataset; retain &amp;dataset_var_list; set _&amp;adam_dataset._prefin; run; *** Prepare a macro variable with the sort-key for sorting of the final ADaM dataset; data _NULL_; length sort_key $1000.; if &quot;&amp;sort_key&quot; ne &quot;&quot; then sort_key = &quot;&amp;sort_key&quot;; else if find(&quot;&amp;dataset_var_list&quot;, &quot;USUBJID&quot;) gt 0 and find(&quot;&amp;dataset_var_list&quot;, &quot;ASEQ&quot;) gt 0 then sort_key = &quot;USUBJID ASEQ&quot;; else if find(&quot;&amp;dataset_var_list&quot;, &quot;USUBJID&quot;) gt 0 and find(&quot;&amp;dataset_var_list&quot;, &quot;PARAM&quot;) gt 0 and find(&quot;&amp;dataset_var_list&quot;, &quot;AVISITN&quot;) gt 0 then sort_key = &quot;USUBJID PARAM AVISITN&quot;; else if find(&quot;&amp;dataset_var_list&quot;, &quot;USUBJID&quot;) gt 0 and find(&quot;&amp;dataset_var_list&quot;, &quot;PARAM&quot;) gt 0 and find(&quot;&amp;dataset_var_list&quot;, &quot;AVISIT&quot;) gt 0 then sort_key = &quot;USUBJID PARAM AVISIT&quot;; else if find(&quot;&amp;dataset_var_list&quot;, &quot;USUBJID&quot;) gt 0 and find(&quot;&amp;dataset_var_list&quot;, &quot;PARAM&quot;) gt 0 then sort_key = &quot;USUBJID PARAM&quot;; else if find(&quot;&amp;dataset_var_list&quot;, &quot;USUBJID&quot;) gt 0 and find(&quot;&amp;dataset_var_list&quot;, &quot;PARAM&quot;) gt 0 then sort_key = &quot;USUBJID PARAM&quot;; else if find(&quot;&amp;dataset_var_list&quot;, &quot;USUBJID&quot;) gt 0 then sort_key = &quot;USUBJID&quot;; else put &quot;WARNING: Dataset could not be sorted, please provide merge-key&quot;; call symput(&quot;sort_key_final&quot;, strip(sort_key)); put &quot;Dataset sorted by &quot; sort_key; run; options quotelenmax; *** Sort final ADaM dataset by USUBJID and, if applicable, sequence number or an other variable; %if &amp;sort_key_final ne %then %do; proc sort data = &amp;adam_dataset; by &amp;sort_key_final; run; %end; *** Check whether the variable lengths and the variable types specified in the specifications are consistent with the lengths and types of variables in the final ADaM dataset and whether any variable exceeds a length of 200 characters; *** Prepare a dataset with all variable names occuring in the final dataset in one column and the corresponding length in another column; proc contents data=&amp;adam_dataset out=_&amp;adam_dataset._real_var_lengths noprint; run; *** Check for which ADaM variables the length / type has to be corrected in the specification file / final dataset and for which ADaM variables the maximal length of 200 characters is exceeded (a warning is created for such entries and the entry is outputted in a dataset for tracking); proc sort data=_&amp;adam_dataset._specs; by Variable_Name Display_Format; run; proc sort data=_&amp;adam_dataset._real_var_lengths; by Name Length; run; data &amp;adam_dataset._lengths; merge _&amp;adam_dataset._specs (in=inSPECS rename=(Variable_Type=Type_Specs)) _&amp;adam_dataset._real_var_lengths (in=inADaM rename=(Name=Variable_Name TYPE=Variable_Type) keep=NAME TYPE LENGTH LABEL); by Variable_Name; Variable_Name = strip(Variable_Name); *** Prepare warnings; if LENGTH gt 200 then put &quot;WARNING: Length of variable &quot; Variable_Name &quot; is greater 200 (user-defined)&quot;; if LENGTH ne Display_Format then put &quot;WARNING: Length of variable &quot; Variable_Name &quot; in final &amp;adam_dataset dataset differs from the length specified in the specifications (user-defined)&quot;; if (Variable_Type eq 1 and find(upcase(Type_Specs), &quot;NUM&quot;) eq 0) or (Variable_Type eq 2 and find(upcase(Type_Specs), &quot;CHAR&quot;) eq 0) then put &quot;WARNING: Type of variable &quot; Variable_Name &quot; differs between final &amp;adam_dataset dataset and specifications (user-defined)&quot;; *** Output entries for which adaptions are necessary; if LENGTH gt 200 or LENGTH ne Display_Format then LENGTH_ERROR = &quot;Y&quot;; if (Variable_Type eq 1 and find(upcase(Type_Specs), &quot;NUM&quot;) eq 0) or (Variable_Type eq 2 and find(upcase(Type_Specs), &quot;CHAR&quot;) eq 0) then TYPE_ERROR = &quot;Y&quot;; run; *** Delete temporary datasets if requested in the macro call; %if &amp;delete ne %then %do; proc datasets lib=work nolist; delete _&amp;adam_dataset._specs_for_chk _&amp;adam_dataset._specs _&amp;adam_dataset _&amp;adam_dataset._prefin _&amp;adam_dataset._real_var_lengths _&amp;adam_dataset._all_var ; quit; %end; %mend create_adam_dataset; 28.4.3 %make_empty_dataset Creation of dummy_datasets with assigned attrib, label and length according .csv input but zero records .csv dummy_datasets %LET specification_path = Z:\\CDISC\\STUDIES\\MEDIWOUND1\\ADaM\\ADaM_Specifications\\CSV; %LET specification_filename = MW2010_ADaM_Specification.csv; %macro make_empty_dataset (metadatafile, dataset); proc import datafile = &quot;&amp;metadatafile&quot; replace dbms = csv out = _temp; guessingrows = 1000; getnames = yes; delimiter = &#39;;&#39;; run; data &amp;dataset._temp; length len $3. variable_label $60.; set _temp (where = (dataset_name = &quot;&amp;dataset&quot;)); len = &quot;8&quot;; *** must be adapted in excel worksheet; if upcase(variable_type) = &quot;CHAR&quot; and display_format ne . /*and length(display_format) in (1 2 3)*/ then len = strip(vvalue(display_format)); run; /* proc import datafile=&quot;&amp;metadatafile&quot; out=_temp dbms=excelcs replace; sheet=&quot;VARIABLE_METADATA&quot;; run; */ **sort the dataset by expected specified variable order; /*proc sort data=_temp; where domain = &quot;&amp;dataset&quot;; by varnum; run; */ **create keepstring macro variable and load metadata **information into macro variables; %global &amp;dataset.KEEPSTRING; data aaa; set &amp;dataset._temp nobs= nobs end=eof; if _n_ = 1 then call symput (&quot;vars&quot;, compress (put(nobs, 3.))); variable_label = tranwrd(variable_label, &#39;%&#39;, &#39;%NRSTR(%%)&#39;); call symputx(&#39;var&#39; || compress(put(_n_, 3.)), variable_name); call symputx(&#39;label&#39; || compress(put(_n_, 3.)), variable_label); call symputx(&#39;length&#39; || compress(put(_n_, 3.)), len); *put(length, 3.)); **valid ODM types include TEXT, INTEGER, FLOAT, DATETIME, **DATE, TIME and map to SAS numeric or character; if upcase(variable_type) in (&quot;NUM&quot; &quot;INTEGER&quot;, &quot;FLOAT&quot;) then call symputx(&#39;type&#39; || compress(put(_n_, 3.)), &quot;&quot;); else if upcase(variable_type) in (&quot;CHAR&quot; &quot;TEXT&quot;, &quot;DATE&quot;, &quot;DATETIME&quot;, &quot;TIME&quot;) then call symputx(&#39;type&#39; || compress(put(_n_, 3.)), &quot;$&quot;); else put &quot;ERR&quot; &quot;OR: not using valid ODM type. &quot; variable_type=; **create **Keepstring macro variable; length keepstring $ 32762; retain keepstring; keepstring = compress(keepstring) || &quot;|&quot; ||left(variable_name); if eof then call symputx(upcase(compress(&quot;&amp;dataset&quot; || &#39;KEEPSTRING&#39;)), left(trim(translate(keepstring, &quot; &quot;, &quot;|&quot;)))); run; **create a 0-observation template data set used for assigning **variable attributes to the actual data sets; data EMPTY_&amp;dataset; %do i=1 %to &amp;vars; attrib &amp;&amp;var&amp;i label= &quot;&amp;&amp;label&amp;i&quot; length= &amp;&amp;type&amp;i.&amp;&amp;length&amp;i... ; %if &amp;&amp;type&amp;i=$ %then retain &amp;&amp;var&amp;i &#39;&#39;; %else retain &amp;&amp;var&amp;i .; ; %end; if 0; run; %mend make_empty_dataset; %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADSL); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADVS); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPAIN); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADMH); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADCM); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADAE); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPEBL); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADLOCLB); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADWDESC); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADTWDESC); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADSLTW); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPRIM); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADSURGEX); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADTTEER); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADBLOOD); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADTTEWC); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADSLPROC); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADCIRC); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADCENTLB); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPRIMTW); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADER100); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADER100T); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADTTER1); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADTTER1T); /*%make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADWC100);*/ %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADTTWC1T); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADTTWC1); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADBLTVOL); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADSAFE); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADBLGLUC); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADGRAFT); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADGRAFTW); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADSURGTW); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADTTEHOS); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADEXPLOR); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADCIRCBL); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPRIMSG); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADSURGSG); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADTTERSG); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADLFU); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADMVSSPT); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADMVSS); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPOSAPT); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPOSAS); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADBVLTYP); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPHSEDA); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPHAREX); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPHSURG); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPHBLD); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPHGRAF); %make_empty_dataset(metadatafile=&amp;specification_path.\\&amp;specification_filename., dataset=ADPHBLTV); 28.4.4 %DTC2DT ISO 8601 Date and Time Conversions. SDTM Date or DateTime variables are saved as character which have to be converted to numeric values in ADaM. SDTM DTCDTCSAS DTC2DTDTCADaMSAS/ SDTM DTCSAS SASADaM BDSADTADTMADY REFDTDY macro parameter Title dtcvar SDTM Date or DateTime variable as character prefix prefix of splitted/converted numeric Date, Time and/or DateTime variable(s) refdt SDTM reference Date, if calculation of relative days is needed; Content Content Input SDTM Date/DateTime variable as character string Output ADaM Date (-DT) / Time (-TM) / DateTime (-DTM) variable(s) as numeric value Content Format of output variable(s) could be: &amp;prefix.DT yymmdd10. &amp;prefix.TM time5. &amp;prefix.DTM e8601dt19.; %macro dtc2dt(dtcvar, prefix, refdt= ); &amp;prefix.DTM = .; &amp;prefix.DT = .; &amp;prefix.TM = .; if length(&amp;dtcvar)=10 and index(&amp;dtcvar,&#39;--&#39;)=0 then &amp;prefix.DT = input(&amp;dtcvar, yymmdd10.); else if length(&amp;dtcvar)=16 and index(&amp;dtcvar,&#39;--&#39;)=0 and index(&amp;dtcvar,&#39;-:&#39;)=0 then do; &amp;prefix.DTM = input(trim(&amp;dtcvar) || &quot;:00&quot;, e8601dt19.); &amp;prefix.DT = datepart(&amp;prefix.dtm); &amp;prefix.TM = input(substr(&amp;dtcvar,12,2) || &quot;:&quot; || substr(&amp;dtcvar,15,2), time5.); end; else if length(&amp;dtcvar)=19 and index(&amp;dtcvar,&#39;--&#39;)=0 and index(&amp;dtcvar,&#39;-:&#39;)=0 then do; &amp;prefix.DTM = input(trim(&amp;dtcvar), e8601dt19.); &amp;prefix.DT = datepart(&amp;prefix.dtm); &amp;prefix.TM = input(substr(&amp;dtcvar,12,2) || &quot;:&quot; || substr(&amp;dtcvar,15,2) || &quot;:&quot; || substr(&amp;dtcvar,18,2), time8.); end; %if &amp;refdt ^= %then %do; if . &lt; &amp;prefix.dt &lt; &amp;refdt - &amp;refdt then &amp;prefix.DY = &amp;prefix.dt - &amp;refdt; else if &amp;prefix.dt &gt;= &amp;refdt then &amp;prefix.DY = &amp;prefix.dt - &amp;refdt + 1; %end; %mend dtc2dt; *** Usage; Data ADaM.ADLB; Merge SDTM.LB ADaM.ADSL (keep=usubjid trtsdt); By usubjid; . . . ** convert the lab date to a SAS date for variable ADT; ** and calculate the study day for variable ADY; %dtc2dt(LBDTC, refdt=TRTSDT ); Run; 28.4.5 %imputed_date Imputation of date parts of partial dates to be able to compare partial date (e.g. Medical History) with other dates (e.g. Start of Treatment)  *** macro parameter: - dtcvar = SDTM Date variable as character, which migth be partial - prefix = prefix of Date Imputation Flag of date variable - timepoint = S = Start date, EN = End date; %macro imputed_date(dtvar, prefix, timepoint); if length(&amp;dtvar) eq 4 then do; &amp;prefix.&amp;timepoint.DT = input((strip(&amp;dtvar) || &quot;-01-01&quot;), YYMMDD10.); &amp;prefix.&amp;timepoint.DTF = &quot;M&quot;; end; else if length(&amp;dtvar) eq 7 then do; &amp;prefix.&amp;timepoint.DT = input((strip(&amp;dtvar) || &quot;-01&quot;), YYMMDD10.); &amp;prefix.&amp;timepoint.DTF = &quot;D&quot;; end; else if length(&amp;dtvar) eq 10 then do; &amp;prefix.&amp;timepoint.DT = input(strip(&amp;dtvar), YYMMDD10.); &amp;prefix.&amp;timepoint.DTF = &quot;&quot;; end; else if length(&amp;dtvar) = 0 then &amp;prefix.&amp;timepoint.DTF = &quot;Y&quot;; %mend imputed_date; 28.4.6 %mergsupp Merging in Supplemental Qualifiers SUPP-SDTMADaMDOMAINS ADSLSUPPDMADAESUPPAE Ex&gt; ADSLSUPPDMQNAM =RACEOTHQNAM =RANDDTCRACEOTHRANDDTCADSL \\[ \\begin{array}{lllll} \\hline \\text { STUDYID } &amp; \\text { RDOMAIN } &amp; \\text { USUBJID } &amp; \\text { QNAM } &amp; \\text { QLABEL } \\\\ \\hline \\text { XYZ123 } &amp; \\text { DM } &amp; \\text { UNI101 } &amp; \\text { RACEOTH } &amp; \\text { Race, Other } \\\\ \\text { XYZ123 } &amp; \\text { DM } &amp; \\text { UNI101 } &amp; \\text { RANDDTC } &amp; \\begin{array}{l} \\text { Date of } \\\\ \\text { Randomization } \\end{array} \\\\ \\text { XYZ123 } &amp; \\text { DM } &amp; \\text { UNI102 } &amp; \\text { RANDDTC } &amp; \\begin{array}{l} \\text { Date of } \\\\ \\text { Randomization } \\end{array} \\\\ \\text { XYZ123 } &amp; \\text { DM } &amp; \\text { UNI103 } &amp; \\text { RANDDTC } &amp; \\begin{array}{l} \\text { Date of } \\\\ \\text { Randomization } \\end{array} \\\\ \\text { XYZ123 } &amp; \\text { DM } &amp; \\text { UNI104 } &amp; \\text { RANDDTC } &amp; \\begin{array}{l} \\text { Date of } \\\\ \\text { Randomization } \\end{array} \\\\ \\hline \\end{array} \\] *------------------------------------------------------------; * Merge supplemental qualifiers into the parent SDTM domain; * This can either be for an entire library or for specified * domains; *------------------------------------------------------------; %macro mergsupp(sourcelib=library, outlib=WORK, domains= , suppqual=0); %local domain; %** de-normalize suppqual and merge into the given domain; %macro domainx(domain= ,suppqual=0); %local suppdata idvar varlist nvars; %if &amp;suppqual %then %let suppdata=suppqual; %else %let suppdata=supp&amp;domain; ; %* count the number of supplemental qualifiers for the given domain; proc sort data = &amp;sourcelib..&amp;suppdata out = nvars nodupkey; where rdomain=upcase(&quot;&amp;domain&quot;); by qnam idvar; run; data _null_; set nvars end=eof; by qnam idvar; length varlist $200; retain varlist; if not first.qnam then put &#39;PROB&#39; &#39;LEM: More than one IDVAR for the domain-- &#39; rdomain= qnam= idvar= ; else do; nvars + 1; varlist = trim(varlist) || &quot; &quot; || trim(qnam); end; if eof then do; call symput(&quot;nvars&quot;, put(nvars, 2.)); call symput(&quot;varlist&quot;, trim(left(varlist))); call symput(&quot;idvar&quot;, trim(idvar)); end; run; %put domain=&amp;domain idvar=&amp;idvar nvars=&amp;nvars varlist=&amp;varlist; proc sort data = &amp;sourcelib..&amp;suppdata out = supp&amp;domain; where rdomain=upcase(&quot;&amp;domain&quot;); by usubjid idvar idvarval; run; %* determine whether IDVAR in the parent domain is character or numeric; %if &amp;idvar^= %then %do; %let dsetnum=%sysfunc(open(&amp;sourcelib..&amp;domain)); %let varnum=%sysfunc(varnum(&amp;dsetnum,&amp;idvar)); %let idtype=%sysfunc(vartype(&amp;dsetnum,&amp;varnum)); %let rc=%sysfunc(close(&amp;dsetnum)); %end; %else %let idtype= ; data supp&amp;domain; set supp&amp;domain; by usubjid idvar idvarval; drop q: idvarval idvar i rdomain; length &amp;varlist $200.; retain &amp;varlist; array vars{*} &amp;varlist; if first.idvarval then do i = 1 to dim(vars); vars{i} = &#39;&#39;; end; do i = 1 to dim(vars); if upcase(qnam)=upcase(vname(vars{i})) then vars{i} = qval; end; %** convert to numeric if numeric in the parent domain; %if &amp;idvar^= and &amp;idtype=N %then &amp;idvar = input(idvarval, best.); %else %if &amp;idvar^= %then &amp;idvar = idvarval; ; if last.idvarval; run; proc sort data = supp&amp;domain; by usubjid &amp;idvar; proc sort data = &amp;sourcelib..&amp;domain out = __tmp; by usubjid &amp;idvar; data &amp;outlib..&amp;domain; merge __tmp supp&amp;domain ; by usubjid &amp;idvar; run; %mend domainx; %*-------------------------------------------------------; %* If DOMAINS parameter specified, then loop through those %* domains; %* otherwise, dynamically identify the SUPPxx data sets and %* go through them all; %*-------------------------------------------------------; %let _wrd=1; %if &amp;DOMAINS^= %then %do %while(%scan(&amp;domains,&amp;_wrd)^= ); %let domain=%scan(&amp;domains,&amp;_wrd); %domainx(domain=&amp;domain,suppqual=0); %let _wrd=%eval(&amp;_wrd+1); %end; %else %do; %** find all of the SUPPxx datasets and loop through each one; ods output members=members; proc contents data = &amp;sourcelib.._all_ memtype=data nods ; run; data members; set members; if upcase(name)=:&#39;SUPP&#39; and upcase(name)^=:&#39;SUPPQUAL&#39; then do; rdomain = substr(name,5,2); put name= rdomain= ; output; end; else if upcase(name)=:&#39;SUPPQUAL&#39; then call symput(&quot;suppqual&quot;,&quot;1&quot;); run; %** loop through each domain; proc sql noprint; select count(distinct rdomain) into :domn from %if &amp;suppqual %then &amp;sourcelib..suppqual; %else members; ; select distinct rdomain into :domain1 - :domain%left(&amp;domn) from %if &amp;suppqual %then &amp;sourcelib..suppqual; %else members; ; %do _i=1 %to &amp;domn; %domainx(domain=&amp;&amp;domain&amp;_i,suppqual=&amp;suppqual); %end; %end; %* if domains not specified explicitly...; %mend mergsupp; 28.5 Project Example MEDIWOUND1 28.5.1 Study Design Study Synoposis IMP NexoBrid Active Ingredient Partially purified Bromelain  Study NexoBridGelStandard of Care Clinical Phase III Sample 331175NexoBridSOC A multicenter, multinational, randomized, controlled, assessor blinded study, performed in subjects with thermal burns, to evaluate the efficacy and safety of NexoBrid compared to Gel Vehicle and compared to Standard of Care NexoBridGelStandard of Care 28.5.2 Primary Objective Incidence of complete eschar removal- Demonstrate superiority of NexoBrid over Gel Vehicle for eschar removal as measured by incidence of complete eschar removal at the end of the topical agent soaking period by a blinded assessor. -NexoBrid Efficacy evaluation Primary target variable Incidence of complete eschar removal in the topical arms (NexoBrid and Gel Vehicle): Incidence of complete eschar removal (ER) 28.5.3 Statistical Analysis logistices//yes / no(Using the exact statement in the SAS procedure PROC LOGISTIC). FisherGelNexoBridchar95  28.5.3.1 Survival data with clustered events Two methods to analyzing survival data with clustered events are presented. The first method is a proportional hazards model which adopts a marginal approach with a working independence assumption. This model can be fitted by SAS PROC PHREG with the robust sandwich estimate option. The second method is a likelihood-based random effects (frailty) model. In the second model, the baseline hazard could be either a priori determined (e.g., Weibull) or approximated by piecewise constant counterpart. The estimation could be carried out by adaptive Gaussian quadrature method which is implemented in SAS PROC NLMIXED.   SAS PROC PHREG Weibull SAS PROC NLMIXED 28.5.4 CDISC Programming 28.5.4.0.1 Initiation *** creation/convertion of SDTM data into ADaM adsl dataset; *** SDTM domains; libname mw10sdtm &quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\SDTM\\Domains\\20201001_Stage_3&quot;; *** ADaM datasets; libname mw10adam &quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\ADaM\\PostHoc_FDA_Request&quot;; *** misc dataasets (additional datasets that don&#39;t qualify as analysis, profile, or tabulation datasets); libname misc &quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\ADaM\\sas_datasets\\misc&quot;; %include &quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\ADaM\\Programmes\\Macros\\M_attrib_to_dataset_v03-4-1.sas&quot;; %include &quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\ADaM\\Programmes\\Macros\\M_mergesupp_v01-3.sas&quot;; %include &quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\ADaM\\Programmes\\Macros\\M_dtc2dt_V01_2_0.sas&quot;; %include &quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\ADaM\\Programmes\\Macros\\M_imputed_date_V01_0_0.sas&quot;; %include &quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\ADaM\\Programmes\\Macros\\M_create_adam_dataset_V01_0_0.sas&quot;; *%include &quot;Z:\\CDISC\\STUDIES\\MEDIWOUND1\\ADaM\\Programmes\\Macros\\Macro_IncludeProgrammes_V02.sas&quot;; *** Import ADaM specification sheet; %let specification_filename = Z:\\CDISC\\STUDIES\\MEDIWOUND1\\ADaM\\ADaM_Specifications\\CSV\\MW2010_ADaM_Specification.csv; proc import datafile=&quot;&amp;specification_filename&quot; replace out=specs dbms=csv; getnames=YES; guessingrows=max; delimiter=&quot;;&quot;; run; 28.5.4.0.2 ADSL creation/convertion of SDTM data into ADaM adsl dataset SDTM variables taken from domain DM, SUPPDM; age ranging \\((A G E&lt;35,&gt;=35, .)\\) Date Convension from SDTM Date to numeric values in ADaM SDTM variables taken from domain CE, SUPPCE; SDTM variables taken from domain HO; SDTM variables taken from domain WC Total Wounds per Patient, Start-/Stop- Date Time per actual treatment SDTM variables taken from domain IE; SDTM variables taken from domain VS (weight, height, bmi); SDTM variables taken from domain DS; restrict to variables that were specified in the specification sheet; 28.5.4.0.3 ADAE get subject specific information from ADSL domain set mw10adam.adsl and empty_adae import information from SDTM.AE; set empty_adae and ae (check for missing AE start dates) process SDTM data; ate/time conversion (character to integer) of AE start date; *** date/time conversion (character to integer) of AE start date; if AESTDTC ne &quot;&quot; then %dtc2dt(dtcvar=AESTDTC, prefix=AST, refdt= ); drop ASTTM; *** Treatment Emergent AE Fflag; if ASTDTM ne . and TRTSDTM ne . then do; if ASTDTM &gt;= TRTSDTM then TEAEFL = &quot;Y&quot;; else if ASTDTM &lt; TRTSDTM then TEAEFL = &quot;&quot;; end; *** duration; if AENDT ne . &amp; ASTDT ne . then ADURN = round(AENDT - ASTDT, 0.1); if ADURN ne . then ADURU = &quot;DAYS&quot;; *** numeric value for severity; if AESEV eq &quot;MILD&quot; then AESEVN = 1; else if AESEV eq &quot;MODERATE&quot; then AESEVN = 2; else if AESEV eq &quot;SEVERE&quot; then AESEVN = 3; *** numeric variable for relatedness; if AEREL eq &quot;NOT RELATED&quot; then AERELN = 1; else if AEREL eq &quot;REMOTELY RELATED&quot; then AERELN = 2; else if AEREL eq &quot;POSSIBLY RELATED&quot; then AERELN = 3; else if AEREL eq &quot;PROBABLY RELATED&quot; then AERELN = 4; else if AEREL eq &quot;RELATED&quot; then AERELN = 5; *** Drug-Related AE Flag; if AERELN = 1 then AERELFL = &quot;N&quot;; else if AERELN in (2,3,4,5) then AERELFL = &quot;Y&quot;; else put &quot;WARNING (user-defined): Missing Causality for &quot; USUBJID &quot; AE No. &quot; AENO; *** numeric variable for outcome; if AEOUT eq &quot;RECOVERED/RESOLVED&quot; then AEOUTN = 1; else if AEOUT eq &quot;RECOVERED/RESOLVED WITH SEQUELAE&quot; then AEOUTN = 2; else if AEOUT eq &quot;NOT RECOVERED/NOT RESOLVED&quot; then AEOUTN = 3; else if AEOUT eq &quot;FATAL&quot; then AEOUTN = 4; 28.5.4.0.4 ADVS PRE FIRST PROCEDURE (Screening visit) for all subject %let paramcd = TEMP\\PULSE\\RESP\\SYSBP\\DIABP\\INTP; %let param = Temperature (C)\\Pulse Rate (beats/min)\\Respiratory Rate (breaths/min)\\Systolic Blood Pressure (mmHg)\\Diastolic Blood Pressure (mmHg)\\Interpretation; *** PRE FIRST PROCEDURE (Screening visit) for all subjects; data for_advs_01_visitContainer_scr; set empty_advs (keep = USUBJID AVISIT PARAM PARAMCD) mw10adam.adsl (keep = USUBJID) ; by USUBJID; if first.USUBJID then do; do i = 1 to 6; AVISIT = &quot;PRE FIRST PROCEDURE&quot;; PARAM = scan(strip(&quot;&amp;param&quot;), i, &quot;\\&quot;); PARAMCD = scan(strip(&quot;&amp;paramcd&quot;), i, &quot;\\&quot;); seq = 1; output; end; end; drop i; run; all subjects with a first procedure (TRT01A ne \"\"); all subjects with a second procedure (TRT02A ne \"\"); all subjects with a third procedure (TRT03A ne \"\"); set together all 3 visitContainer; data for_advs_01_visitContainer_trt03; set empty_advs (keep = USUBJID AVISIT PARAM PARAMCD) mw10adam.adsl (keep = USUBJID TRT03A where = (TRT03A ne &quot;&quot;)) ; by USUBJID; if first.USUBJID then do; do i = 1 to 6; AVISIT = &quot;POST THIRD PROCEDURE&quot;; PARAM = scan(strip(&quot;&amp;param&quot;), i, &quot;\\&quot;); PARAMCD = scan(strip(&quot;&amp;paramcd&quot;), i, &quot;\\&quot;); seq = 6; *** skip seq = 5 for calculation of PRE-POST difference; output; end; end; drop i TRT03A; run; *** set together all 3 visitContainer; data for_advs_01_visitContainer_all; set for_advs_01_visitContainer_scr for_advs_01_visitContainer_trt01 for_advs_01_visitContainer_trt02 for_advs_01_visitContainer_trt03 ; by USUBJID; run; POST-PRE DIFF PROCEDURES AVISIT_lag = lag1(AVISIT); AVAL_lag = lag1(AVAL); PARAM_lag = lag1(PARAM); PARAM_new = &quot;Diff. &quot; || strip(PARAM); f strip(PARAM) = strip(PARAM_lag) and strip(AVISIT) = &quot;POST FIRST PROCEDURE&quot; and strip(AVISIT_lag) = &quot;PRE FIRST PROCEDURE&quot; then do; if AVAL_lag ne . and AVAL ne . then AVAL_new = AVAL_lag - AVAL; AVISIT_new = &quot;PRE-POST DIFF FIRST PROCEDURE&quot;; seq_new = 3; end; if strip(PARAM) = strip(PARAM_lag) and strip(AVISIT) = &quot;POST SECOND PROCEDURE&quot; and strip(AVISIT_lag) = &quot;POST FIRST PROCEDURE&quot; then do; if AVAL_lag ne . and AVAL ne . then AVAL_new = AVAL_lag - AVAL; AVISIT_new = &quot;PRE-POST DIFF SECOND PROCEDURE&quot;; seq_new = 5; end; if strip(PARAM) = strip(PARAM_lag) and strip(AVISIT) = &quot;POST THIRD PROCEDURE&quot; and strip(AVISIT_lag) = &quot;POST SECOND PROCEDURE&quot; then do; if AVAL_lag ne . and AVAL ne . then AVAL_new = AVAL_lag - AVAL; AVISIT_new = &quot;PRE-POST DIFF THIRD PROCEDURE&quot;; seq_new = 7; end; if strip(PARAM) = strip(PARAM_lag) and strip(AVISIT) = &quot;DAY 2&quot; and strip(AVISIT_lag) = &quot;DAY 1&quot; then do; if AVAL_lag ne . and AVAL ne . then AVAL_new = AVAL_lag - AVAL; AVISIT_new = &quot;DAY 1 - DAY 2 DIFF&quot;; seq_new = 10; end; ... end; if strip(PARAM) = strip(PARAM_lag) and strip(AVISIT) = &quot;DAY 7&quot; and strip(AVISIT_lag) = &quot;DAY 6&quot; then do; if AVAL_lag ne . and AVAL ne . then AVAL_new = AVAL_lag - AVAL; AVISIT_new = &quot;DAY 6 - DAY 7 DIFF&quot;; seq_new = 20; end; "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
